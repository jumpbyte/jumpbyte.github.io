<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>JumpByte的博客</title>
  
  <subtitle>物质、世界、时间、空间，只不过是人类的幻觉</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.jumpbyte.cn/"/>
  <updated>2017-12-03T09:27:22.843Z</updated>
  <id>http://www.jumpbyte.cn/</id>
  
  <author>
    <name>JumpByte</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>linux线上命令实战演练</title>
    <link href="http://www.jumpbyte.cn/2017/08/10/linux-command-online-practice/"/>
    <id>http://www.jumpbyte.cn/2017/08/10/linux-command-online-practice/</id>
    <published>2017-08-10T10:34:58.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>最近公司运维部门同学联合我们业务部门举行了一场线上实际服务器问题排查演练，其旨在提高我们每个开发人员针对linux中常用的一些命令的使用熟练程度，运维同学出的题都是非常具有代表性，从这次实际的演练中，我们每个人学习到了很多关于多个linux命令综合灵活运用的知识，以下是我们这次的实践演练，分享给大家，一起学习！</p><h3 id="实践1"><a href="#实践1" class="headerlink" title="实践1"></a>实践1</h3><p>有一台linux服务器192.168.1.1的sshd的监听端口是22，如何统计192.168.1.1的sshd服务各种状态（TIME_WAIT/CLOSE_WAIT/ESTABLISHED）的连接数，以便快速定位问题</p><p>实践目的：了解机器连接数情况，便于排查问题<br><a id="more"></a></p><h4 id="参考实践"><a href="#参考实践" class="headerlink" title="参考实践"></a>参考实践</h4><p>有两种实践方式</p><ol><li>第一种<pre><code class="shell">netstat -n | grep 192.168.1.1:22|awk &#39;/^tcp/ {++S[$NF]} END {for(a in S) print a, S[a]}’</code></pre></li><li>第二种<pre><code class="shell">netstat –lnpta|grep ssh|egrep “TIME_WAIT| CLOSE_WAIT| ESTABLISHED”</code></pre></li></ol><h4 id="补充知识点"><a href="#补充知识点" class="headerlink" title="补充知识点"></a>补充知识点</h4><pre><code class="shell">netstat常见参数-a (all)显示所有选项，默认不显示LISTEN相关-t (tcp)仅显示tcp相关选项-u (udp)仅显示udp相关选项-n 拒绝显示别名，能显示数字的全部转化成数字。-l 仅列出有在 Listen (监听) 的服務状态-p 显示建立相关链接的程序名-r 显示路由信息，路由表-e 显示扩展信息，例如uid等-s 按各个协议进行统计-c 每隔一个固定时间，执行该netstat命令。</code></pre><pre><code class="shell">AWKNF:支持记录域个数NR:已经读取的记录数</code></pre><h3 id="实践2"><a href="#实践2" class="headerlink" title="实践2"></a>实践2</h3><p>192.168.1.1中/opt/log/dubbo-access-provider.2017-06-26.log.bz2   日志中，有192.168.1.2 关键字的数据有多少条<br>主要目的：当前线上日志文件统一要求以bz2 压缩之后保留在本机，当需要查看历史日志时，解压需要耗费大量时间，如何在不解压的情况下直接查看内容</p><h4 id="参考实践-1"><a href="#参考实践-1" class="headerlink" title="参考实践"></a>参考实践</h4><p>有以下三种实践方式</p><pre><code>bzcat /opt/log/dubbo-access-provider.2017-06-26.log.bz2 |grep 192.168.1.2|wc –lbzgrep 10.37.9.11 /opt/log/dubbo-access-provider.2017-06-26.log.bz2 |wc –lless /opt/log/dubbo-access-provider.2017-06-26.log.bz2|grep &#39;192.168.1.2&#39; |wc –l</code></pre><h3 id="实践3"><a href="#实践3" class="headerlink" title="实践3"></a>实践3</h3><p>打包192.168.1.1服务器的 /opt/web/order-feature 目录，排除掉目录中的logs 和 work两个目录,打包后的文件名格式：自己的邮箱前缀.tar.gz(例如：zhangsan.tar.gz)。打包好的文件存放在/opt/backup目录下</p><p>主要目的：实际应用场景较为频繁，在项目代码需要打包迁移时，常常需要排除掉日志目录(如log目录)。</p><h4 id="参考实践-2"><a href="#参考实践-2" class="headerlink" title="参考实践"></a>参考实践</h4><pre><code class="shell">tar -zcvf /opt/backup/yangjinan.tar.gz  \            –exclude /opt/web/order-feature/work  \             –exclude /opt/web/order-feature/logs   \            /opt/web/order-feature</code></pre><h4 id="补充知识点-1"><a href="#补充知识点-1" class="headerlink" title="补充知识点"></a>补充知识点</h4><p>使用tar命令<br>主选项：<br>c 创建新的档案文件。如果用户想备份一个目录或是一些文件，就要选择这个选项。相当于打包。<br>x 从档案文件中释放文件。相当于拆包。<br>t 列出档案文件的内容，查看已经备份了哪些文件。<br>特别注意，在参数的下达中， c/x/t 仅能存在一个！不可同时存在！因为不可能同时压缩与解压缩。<br>辅助选项：<br>-z ：是否同时具有 gzip 的属性？亦即是否需要用 gzip 压缩或解压？ 一般格式为xx.tar.gz或xx. tgz<br>-j ：是否同时具有 bzip2 的属性？亦即是否需要用 bzip2 压缩或解压？一般格式为xx.tar.bz2<br>-v ：压缩的过程中显示文件！这个常用<br>-f ：使用档名，请留意，在 f 之后要立即接档名喔！不要再加其他参数！<br>-p ：使用原文件的原来属性（属性不会依据使用者而变）<br>–exclude FILE：在压缩的过程中，不要将 FILE 打包！</p><h3 id="实践4"><a href="#实践4" class="headerlink" title="实践4"></a>实践4</h3><p>查询192.168.1.1服务器运行服务的总线程数</p><p>主要目的:当机器线程数超报警阀值时，能快速查出相关进程及线程信息</p><h4 id="参考实践-3"><a href="#参考实践-3" class="headerlink" title="参考实践"></a>参考实践</h4><ul><li>第一种方式<br>ps -eLf |wc –l</li><li>第二种方式<br>pstree -p | wc –l</li></ul><h4 id="补充知识点-2"><a href="#补充知识点-2" class="headerlink" title="补充知识点"></a>补充知识点</h4><p>名称：ps<br>使用权限：所有使用者<br>使用方式：ps [options] [–help]<br>说明：显示瞬间行程 (process) 的动态<br>参数：ps的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A    列出所有的进程<br>-w    显示加宽可以显示较多的资讯<br>-au    显示较详细的资讯<br>-aux    显示所有包含其他使用者的行程</p><p>############################################################</p><p>常用参数：</p><p>-A 显示所有进程（等价于-e）(utility)<br>-a 显示一个终端的所有进程，除了会话引线<br>-N 忽略选择。<br>-d 显示所有进程，但省略所有的会话引线(utility)<br>-x 显示没有控制终端的进程，同时显示各个命令的具体路径。dx不可合用。（utility）<br>-p pid 进程使用cpu的时间<br>-u uid or username 选择有效的用户id或者是用户名<br>-g gid or groupname 显示组的所有进程。<br>U username 显示该用户下的所有进程，且显示各个命令的详细路径。如:ps U zhang;(utility)<br>-f 全部列出，通常和其他选项联用。如：ps -fa or ps -fx and so on.<br>-l 长格式（有F,wchan,C 等字段）<br>-j 作业格式<br>-o 用户自定义格式。<br>v 以虚拟存储器格式显示<br>s 以信号格式显示<br>-m 显示所有的线程<br>-H 显示进程的层次(和其它的命令合用，如：ps -Ha)（utility）<br>e 命令之后显示环境（如：ps -d e; ps -a e）(utility)<br>h 不显示第一行</p><p>############################################################</p><p>ps命令常用用法（方便查看系统进程）</p><p>1）ps a 显示现行终端机下的所有程序，包括其他用户的程序。<br>2）ps -A 显示所有进程。<br>3）ps c 列出程序时，显示每个程序真正的指令名称，而不包含路径，参数或常驻服务的标示。<br>4）ps -e 此参数的效果和指定“A”参数相同。<br>5）ps e 列出程序时，显示每个程序所使用的环境变量。<br>6）ps f 用ASCII字符显示树状结构，表达程序间的相互关系。<br>7）ps -H 显示树状结构，表示程序间的相互关系。<br>8）ps -N 显示所有的程序，除了执行ps指令终端机下的程序之外。<br>9）ps s 采用程序信号的格式显示程序状况。<br>10）ps S 列出程序时，包括已中断的子程序资料。<br>11）ps -t&lt;终端机编号&gt; 　指定终端机编号，并列出属于该终端机的程序的状况。<br>12）ps u 　以用户为主的格式来显示程序状况。<br>13）ps x 　显示所有程序，不以终端机来区分。<br>最常用的方法是ps -aux,然后再利用一个管道符号名称：ps</p><h3 id="实践5"><a href="#实践5" class="headerlink" title="实践5"></a>实践5</h3><p>找出192.168.1.1最大的文件名中包含log的文件，假设因为该文件导致了磁盘空间报警，并且该文件是某个正在运行的tomcat服务异常产生的日志，需要处理该文件（该文件可进行任意操作包括删除），以释放空间。请给出相关思路</p><p>主要目的：磁盘空间问题为常见问题，需要定位哪些目录或者文件导致，并及时清理</p><h4 id="参考实践-4"><a href="#参考实践-4" class="headerlink" title="参考实践"></a>参考实践</h4><ol><li><p>df -h   + du -sh <em>|sort -rh 命令结合，定位出具体的占用空间最大的文件；或：<br> find /opt/ -type f -name “</em>log<em>“|xargs ls -lSh|more<br> du -a / | sort -rn | grep log | more<br> find / -name ‘</em>log*’ -size +1000M -exec du -h {} \;</p></li><li><p>假设找到的文件为a.log,echo “”&gt;a.log 将该文件清空，空间即可释放<br>很多同学直接rm -f a.log, 来处理。这样文件虽然删除，但是因tomcat服务仍在运行，会导致空间不能释放，此时需要重启tomcat才能将空间释放。</p></li></ol><h3 id="实践6"><a href="#实践6" class="headerlink" title="实践6"></a>实践6</h3><p>提取192.168.1.1服务器上/opt/log/localhost_access.log-20170609(nginx访问日志)，访问前10的IP地址及访问次数</p><p>主要目的：主要目的：cat,awk,uniq,sort,head命令结合使用，日常日志分析中用到的比较多</p><h4 id="参考实践-5"><a href="#参考实践-5" class="headerlink" title="参考实践"></a>参考实践</h4><ol><li>第一种</li></ol><pre><code class="shell">cat /opt/log/localhost_access.log-20170609|awk &#39;{print $2}&#39; | sort | uniq -c | sort -rn | head -n 10</code></pre><ol><li>第二种</li></ol><pre><code class="shell">cat localhost_access.log-20170609 | awk &#39;{a[$2]++}END{for(i in a) print i,a[i]}&#39;| sort -k2nr |head -10</code></pre><h3 id="实践7"><a href="#实践7" class="headerlink" title="实践7"></a>实践7</h3><p>显示192.168.1.1  /etc/nginx.conf 文件中不以#号开头的行</p><p>主要目的：了解grep /sed 的用法</p><h4 id="参考实践-6"><a href="#参考实践-6" class="headerlink" title="参考实践"></a>参考实践</h4><ol><li>第一种方式<br>sed -n  ‘/^[#]/!p’    /etc/nginx.conf</li><li>第二种方式<br>sed -e ‘/^#/d’ /etc/nginx.conf</li><li>第三种方式<br>grep -v “^#” /etc/nginx.conf</li></ol><h3 id="实践8"><a href="#实践8" class="headerlink" title="实践8"></a>实践8</h3><p>192.168.1.1磁盘IO异常如何排查，类似写入慢或当前使用率较高，请查出导致磁盘IO异常高的非java进程ID</p><p>主要目的:查找占用磁盘IO服务名称及磁盘自身故障</p><h4 id="参考实践-7"><a href="#参考实践-7" class="headerlink" title="参考实践"></a>参考实践</h4><ol><li>iotop -o 查看当前正在写磁盘操作的所有服务进程id 、写入IO值、服务路径，可以通过相关参数找到对应的服务名称。</li><li>如果此时各项写入指标都很低，基本没有大的写入操作，则需要排查磁盘自身。可以查看系统dmesg 或 cat /var/log/message 看看是否有相关的磁盘异常报错，同时可以在写入慢的磁盘上touch 一个空文件看看，是否磁盘故障导致无法写入。</li></ol><h3 id="实践9"><a href="#实践9" class="headerlink" title="实践9"></a>实践9</h3><p>某服务器CPU使用率达到99%，排查是哪个程序的哪个线程导致的高CPU</p><h4 id="参考实践-8"><a href="#参考实践-8" class="headerlink" title="参考实践"></a>参考实践</h4><p><strong>实践思路：</strong> </p><ol><li>先找到耗CPU高的进程； </li><li>找到耗CPU高的线程； </li><li>找到耗CPU高的线程对应的业务代码；</li></ol><p><strong>具体操作</strong></p><ol><li><p>执行“top -c”命令，显示进程运行信息列表，键入大写P，按CPU使用率降序排列</p></li><li><p>如从步骤1中获取到进程PID为10765的进程，使用CPU资源最高30.9%；至此，已找到耗CPU最高的进程，进程PID为10765，后续命令中需要使用到</p></li><li><p>找出消耗CPU最高的线程，一个进程内有很多线程，执行“top -Hp 10765”，显示进程ID为10765的线程列表，键入大写P后，按CPU使用率降序排列</p></li><li><p>假设步骤3中，找到PID为10804的线程，CPU使用率最高；将线程ID(10804)按16进制展示，执行指令<code>printf &quot;%x\n&quot; 10804</code>（因java线程Id是以16进制显示），至此，找到了CPU使用率最高的线程ID为10804，并获取到10804的16进制标识：2a34</p></li><li><p>通过jstack检索到进程(进程ID=10765)中，最耗CPU的线程(线程ID=2a34)的线程栈信息； 执行指令<code>jstack 10765 | grep &quot;2a34&quot; -C5 --color</code></p></li><li>通过上面步骤假设找到了耗CPU高的线程对应的线程名称“AsyncLogger-1”，而这个线程名称是我们业务代码中给线程取的名称，现在就可以快速定位到业务代码了。</li></ol><p>tips:给线程取一个与业务处理相关的名称，对快速定位问题尤为重要</p><h3 id="实践10"><a href="#实践10" class="headerlink" title="实践10"></a>实践10</h3><p>某java应用大量消耗内存，导致OutOfMemoryError</p><h4 id="参考实践-9"><a href="#参考实践-9" class="headerlink" title="参考实践"></a>参考实践</h4><p><strong>实践思路：</strong></p><ol><li>什么对象消耗内存最大；</li><li>是否创建了太多的线程；</li><li>新生的、老年代现在内存使用情况，确认是不是整体内存分配太小了；</li><li>实时查看新生的、老年代内存使用情况，GC情况</li><li>代码层检查，是否有大对象创建？需要调用close()或dispose()来回收的资源是否回收了？</li></ol><p><strong>具体操作：</strong></p><ul><li>执行“jmap -histo:live 10765 | more”命令，以表格的方式显示存活对象的信息(已按对象所占bytes大小进行降序排列)：<br>其中，10765为进程ID，更多用法，通过“man jmap”寻求帮助。<blockquote><p>tips：如果发现某类对象占用内存很大(几个G的大小)，很可能是有问题的。基本都是因为：该类对象创建太多，且一直未释放。比如：使用完IO资源后，未调用close()接口关闭、释放资源；又比如：消费者消费速度慢(或停止消费了)，而生产者不断往队列中投递任务，导致队列中任务累积过多，任务对象占用内存太多而产生OutOfMemoryError</p></blockquote></li><li>执行“pstree -p 10765 | wc -l”，查看进程内的线程数,其中，10765为进程ID。<blockquote><p>tips:每个线程需要分配线程栈内存，创建线程太多，可能导致OutOfMemoryError</p></blockquote></li><li>执行“jmap -heap 10765”，查看堆(新生代、老年代)内存分配大小及使用情况</li><li>执行“jstat -gc 10765 1000”，查看各个区内存使用情况及GC情况,其中，10765为进程ID，1000为数据刷新间隔的毫秒数<blockquote><p>tips:具体字段含义，通过“man jstat”寻求帮助。主要查看：EC：Eden区容量，EU：Eden区已使用量，OC：Old区容量，OU：Old区已使用量；<br>YGC：YongGC次数，YGCT：YongGC耗时，FGC：FullGC次数，FGCT：FullGC耗时；</p></blockquote></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;最近公司运维部门同学联合我们业务部门举行了一场线上实际服务器问题排查演练，其旨在提高我们每个开发人员针对linux中常用的一些命令的使用熟练程度，运维同学出的题都是非常具有代表性，从这次实际的演练中，我们每个人学习到了很多关于多个linux命令综合灵活运用的知识，以下是我们这次的实践演练，分享给大家，一起学习！&lt;/p&gt;
&lt;h3 id=&quot;实践1&quot;&gt;&lt;a href=&quot;#实践1&quot; class=&quot;headerlink&quot; title=&quot;实践1&quot;&gt;&lt;/a&gt;实践1&lt;/h3&gt;&lt;p&gt;有一台linux服务器192.168.1.1的sshd的监听端口是22，如何统计192.168.1.1的sshd服务各种状态（TIME_WAIT/CLOSE_WAIT/ESTABLISHED）的连接数，以便快速定位问题&lt;/p&gt;
&lt;p&gt;实践目的：了解机器连接数情况，便于排查问题&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.jumpbyte.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.jumpbyte.cn/tags/linux/"/>
    
      <category term="shell" scheme="http://www.jumpbyte.cn/tags/shell/"/>
    
  </entry>
  
  <entry>
    <title>使用Swagger插件丰富增强RESTful服务</title>
    <link href="http://www.jumpbyte.cn/2016/09/03/enriching-restful-services-swagger/"/>
    <id>http://www.jumpbyte.cn/2016/09/03/enriching-restful-services-swagger/</id>
    <published>2016-09-03T14:04:44.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>通常来说调用一个RESTful服务接口可以说是一个比较繁杂的事情,因为有很多非常低效的任务要去做。我们非常羡慕使用WS*/SOAP协议服务的人:他们可以很容易地基于正式的WSDL接口规范生成一个客户端API，这样大大的简化了服务的调用。在很长一段时间内REST世界中缺乏广泛的正式规范和生成工具。但是Swagger的出现改变了这种局面<br><a id="more"></a></p><h2 id="处理RESTful服务现存的问题"><a href="#处理RESTful服务现存的问题" class="headerlink" title="处理RESTful服务现存的问题"></a>处理RESTful服务现存的问题</h2><p>当涉及到调用RESTful服务时，你会遇到两个问题：</p><ul><li>首先要阅读并且理解RESTful服务接口文档</li><li>使用费劲的RESTful服务，你必须创建一个HTTP请求，包括正确的HTTP方法,正确的HTTP头，URL使用正确的参数，在HTTP Body里使用正确的JSON，这些特别是在服务API的变化时,维护成本特别高</li></ul><p>当开发和维护一个RESTful服务时，你会遇到下面问题：</p><ul><li>必须手动再编写一个api文档</li><li>当服务改变时，你必须兼顾同步更新api文档，这个过程是比较容易出现错误</li></ul><p>然而，Swagger就可以解决这些问题</p><h2 id="使用Swagger"><a href="#使用Swagger" class="headerlink" title="使用Swagger"></a>使用Swagger</h2><p>Swagger的核心是一个用来描述RESTful服务规范的语言。但最重要的是，这个规范如同代码生成器和编辑器,提供了一个强大和积极成熟的生态系统工具,。这就是独特的卖点像WADL其他规范语言一样。</p><p>在开发流程中，有两种方式使用<a href="http://swagger.io/getting-started/" target="_blank" rel="external">Swagger</a></p><ul><li>API优先</li><li>服务优先</li></ul><h3 id="API优先"><a href="#API优先" class="headerlink" title="API优先"></a>API优先</h3><p>你可以先写你的Swagger API规范。在此基础上规范可以生成JAX-RS存根资源类和调用服务的客户端库。尽管可以利用<a href="http://editor.swagger.io/" target="_blank" rel="external">Swagger编辑器</a>,用来创建这个规格，但这是一个非常艰难的任务，你需要学习这个规范语言。</p><p>然而,这是必须要做的，因为当你开始一个新项目涉及多个不同公司的团队时,你必须提交一个API规范。这样所有团队可以开始工作,不需要等待服务团队(例如通过生成一个服务的伪实现)</p><p>在这有一个很棒的的工具<a href="http://swagger.io/writing-apis-with-the-swagger-inflector/" target="_blank" rel="external">swagger-inflector</a>。它简化了基于给定的swagge文件JAX-RS服务器的实现,不再有JAX-RS生成的步骤。swagger-inflector在运行时将请求重定向到你的业务逻辑。如果你不提供业务逻辑,将返回伪实现的数据。因此,swagger-inflector还可用于对于一个给定swagger文件进行模拟服务。</p><h3 id="服务优先"><a href="#服务优先" class="headerlink" title="服务优先"></a>服务优先</h3><p>我更喜欢服务优先这种更加实际的方式，看下下面这工作流程图：<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-3/35478687.jpg" alt="使用Swagger服务开发优先流程图"></p><h4 id="服务端"><a href="#服务端" class="headerlink" title="服务端"></a>服务端</h4><p>通常,你开始通过编写JAX-RS资源类开发RESTful服务。然后通过对资源类添加Swaggeer的注解为RESTful API提供额外的文档。大部分的Swaggeer相关注解以前缀“@Api*”开始。资源类最终会像如下的代码:</p><pre><code class="java">@Api(value = &quot;customers&quot;, description = &quot;RESTful API to interact with customer resources.&quot;)@Path(&quot;customers&quot;)public class CustomerResource {    @Inject    private CustomerDAO dao;    @ApiOperation(value = &quot;Get all customers&quot;, notes = &quot;Get all customers matching the given search string.&quot;, responseContainer = &quot;List&quot;, response = Customer.class)    @GET    @Path(&quot;/&quot;)    @Produces(MediaType.APPLICATION_JSON)    public List&lt;Customer&gt; getCustomers(            @ApiParam(value = &quot;The search string is used to find customer by their name. Not case sensetive.&quot;, required = false, defaultValue = &quot;&quot;) @QueryParam(&quot;search&quot;) String searchString,            @ApiParam(value = &quot;Limits the size of the result set&quot;, required = false, defaultValue = &quot;50&quot;) @QueryParam(&quot;limit&quot;) int limit) {        List&lt;Customer&gt; customers = dao.getCustomers(searchString, limit);        return customers;    }    @ApiOperation(value = &quot;Create a new customer&quot;, notes = &quot;Creates a new customer with the given name. The URL of the new customer is returned in the location header.&quot;)    @POST    @Path(&quot;/&quot;)    @Consumes(MediaType.APPLICATION_JSON)    public Response createEmployee(            @ApiParam(value = &quot;customer&#39;s name&quot;, required = true) String customerName)            throws URISyntaxException {        Customer customer = dao.createCustomer(customerName);        URI uri = createNewLocationURI(customer.getId());        Response response = Response.created(uri).build();        return response;    }}</code></pre><p>现在我们可以让Swagger处理带注解的资源类。它将生成正式规范。典型的应该是基于你的API规范以相同步骤创建的一个HTML文档。有几种方法可以实现这它:</p><ul><li>可以在Maven构建过程中生成Swagger规范文档，这个可以通过我们的<a href="https://github.com/kongchen/swagger-maven-plugin" target="_blank" rel="external">swagger-maven-plugin</a>完成</li><li>如果正在使用Dropwizard，可以使用其捆绑插件<a href="https://github.com/federecio/dropwizard-swagger" target="_blank" rel="external">dropwizard-swagger</a>。它会在服务类启动过程中自动生成Swagger规范并且都发布在特定的url下面。这种方式非常非常不错,因为这样可以确保规范和文档跟已发布的服务保持最新。除此之外，不需要关心如何发布规范和文档。</li></ul><p>下面是生成的API规范和我们的RESTful服务：</p><pre><code class="yml">swagger: &quot;2.0&quot;info: {}basePath: &quot;/&quot;tags:- name: &quot;customers&quot;paths:  /customers:    get:      tags:      - &quot;customers&quot;      summary: &quot;Get all customers&quot;      description: &quot;Get all customers matching the given search string.&quot;      operationId: &quot;getCustomers&quot;      consumes:      - &quot;application/json&quot;      produces:      - &quot;application/json&quot;      parameters:      - name: &quot;search&quot;        in: &quot;query&quot;        description: &quot;The search string is used to find customer by their name. Not\          \ case sensetive.&quot;        required: false        type: &quot;string&quot;      - name: &quot;limit&quot;        in: &quot;query&quot;        description: &quot;Limits the size of the result set&quot;        required: false        type: &quot;integer&quot;        default: &quot;50&quot;        format: &quot;int32&quot;      responses:        200:          description: &quot;successful operation&quot;          schema:            type: &quot;array&quot;            items:              $ref: &quot;#/definitions/Customer&quot;    post:      tags:      - &quot;customers&quot;      summary: &quot;Creates a new customer&quot;      description: &quot;Creates a new customer with the given name. &quot;      operationId: &quot;createEmployee&quot;      consumes:      - &quot;application/json&quot;      parameters:      - in: &quot;body&quot;        name: &quot;body&quot;        description: &quot;customer&#39;s name&quot;        required: false        schema:          type: &quot;string&quot;      responses:        default:          description: &quot;successful operation&quot;</code></pre><p>生成的文档，如图：<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-3/92930277.jpg" alt="生成的api文档"></p><p>那么好处是什么呢？我们有了一个自动保持最新的API文档，文档是自动生成的，我们不需要手工去编写。另外，还提供了一个正式API规范标准。该规范可以用来生成一个客户端库(支持生成多个编程语言)，这是我们接下来要做的。</p><h4 id="客户端"><a href="#客户端" class="headerlink" title="客户端"></a>客户端</h4><p>客户端希望使用我们的RESTful服务,可以使用我们发布的Swagger规范来生成客户端库。有以下几种方法来生成：</p><p><strong>使用命令行工具</strong></p><p>为此，我们可以使用<a href="https://github.com/swagger-api/swagger-codegen" target="_blank" rel="external">swagger-codegen</a>命令行工具。下面是一个使用它的命令示例：</p><pre><code class="shell">java -jar modules/swagger-codegen-cli/target/swagger-codegen-cli.jar generate \  -i http://localhost:8080/swagger.json \  -l java \  -o samples/client/customer/java</code></pre><p>上面示例的命令将生成一个完整的Maven项目，可以构建安装到我们自己的仓库中</p><p><strong>使用Maven插件</strong></p><p>然而,我建议通过<a href="https://github.com/swagger-api/swagger-codegen/tree/master/modules/swagger-codegen-maven-plugin" target="_blank" rel="external">swagger-codegen-maven-plugin</a> maven插件在一个现有的项目执行生成操作。通过这种方式,我们可以维护自己项目的pom(而不是生成一个新的项目)，并且完全控制构建配置(SVN/Git位置,构件的仓库url)。这非常适合于一个典型的项目基础设施搭建。</p><pre><code class="xml">&lt;properties&gt;    &lt;yaml.file&gt;${project.basedir}/src/main/resources/prozu-service.yaml&lt;/yaml.file&gt;    &lt;generated-sources-path&gt;${project.build.directory}/generated-sources&lt;/generated-sources-path&gt;    &lt;generated-sources-java-path&gt;main/java&lt;/generated-sources-java-path&gt;    &lt;version.swagger.codegen&gt;2.1.4&lt;/version.swagger.codegen&gt;    &lt;!-- TODO add the properties from target/generated-sources/pom.xml here --&gt;&lt;/properties&gt;&lt;dependencies&gt;    &lt;!-- TODO add the dependencies from target/generated-sources/pom.xml here --&gt;&lt;/dependencies&gt;&lt;build&gt;&lt;plugins&gt;    &lt;plugin&gt;        &lt;groupId&gt;io.swagger&lt;/groupId&gt;        &lt;artifactId&gt;swagger-codegen-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;${version.swagger.codegen}&lt;/version&gt;        &lt;configuration&gt;            &lt;inputSpec&gt;${yaml.file}&lt;/inputSpec&gt;            &lt;configOptions&gt;                &lt;sourceFolder&gt;${generated-sources-java-path}&lt;/sourceFolder&gt;            &lt;/configOptions&gt;            &lt;output&gt;${generated-sources-path}&lt;/output&gt;        &lt;/configuration&gt;        &lt;executions&gt;            &lt;execution&gt;                &lt;id&gt;generate-swagger-javaclient&lt;/id&gt;                &lt;phase&gt;generate-sources&lt;/phase&gt;                &lt;goals&gt;                    &lt;goal&gt;generate&lt;/goal&gt;                &lt;/goals&gt;                &lt;configuration&gt;                    &lt;language&gt;java&lt;/language&gt;                    &lt;modelPackage&gt;${groupId}.prozu.client.model&lt;/modelPackage&gt;                    &lt;apiPackage&gt;${groupId}.prozu.client.api&lt;/apiPackage&gt;                    &lt;invokerPackage&gt;${groupId}.prozu.client.invoker&lt;/invokerPackage&gt;                &lt;/configuration&gt;            &lt;/execution&gt;        &lt;/executions&gt;    &lt;/plugin&gt;    &lt;plugin&gt;        &lt;groupId&gt;org.codehaus.mojo&lt;/groupId&gt;        &lt;artifactId&gt;build-helper-maven-plugin&lt;/artifactId&gt;        &lt;version&gt;1.9.1&lt;/version&gt;        &lt;executions&gt;            &lt;!-- TODO for eclipse/m2e users: install the m2e connector &#39;buildhelper&#39; by selecting &#39;Discover new m2e connectors&#39; while hovering over the follwoing execution tag --&gt;            &lt;execution&gt;                &lt;id&gt;add-generated-source&lt;/id&gt;                &lt;phase&gt;initialize&lt;/phase&gt;                &lt;goals&gt;                    &lt;goal&gt;add-source&lt;/goal&gt;                &lt;/goals&gt;                &lt;configuration&gt;                    &lt;sources&gt;                        &lt;source&gt;${generated-sources-path}/${generated-sources-java-path}&lt;/source&gt;                    &lt;/sources&gt;                &lt;/configuration&gt;            &lt;/execution&gt;        &lt;/executions&gt;    &lt;/plugin&gt;&lt;/plugins&gt;&lt;!-- the following is only necessary if you are using eclipse and m2e --&gt;&lt;pluginManagement&gt;    &lt;plugins&gt;        &lt;plugin&gt;            &lt;groupId&gt;org.eclipse.m2e&lt;/groupId&gt;            &lt;artifactId&gt;lifecycle-mapping&lt;/artifactId&gt;            &lt;version&gt;1.0.0&lt;/version&gt;            &lt;configuration&gt;                &lt;lifecycleMappingMetadata&gt;                    &lt;pluginExecutions&gt;                        &lt;pluginExecution&gt;                            &lt;pluginExecutionFilter&gt;                                &lt;groupId&gt;io.swagger&lt;/groupId&gt;                                &lt;artifactId&gt;swagger-codegen-maven-plugin&lt;/artifactId&gt;                                &lt;versionRange&gt;[${version.swagger.codegen},)&lt;/versionRange&gt;                                &lt;goals&gt;                                    &lt;goal&gt;generate&lt;/goal&gt;                                &lt;/goals&gt;                            &lt;/pluginExecutionFilter&gt;                            &lt;action&gt;                                &lt;execute /&gt;                            &lt;/action&gt;                        &lt;/pluginExecution&gt;                    &lt;/pluginExecutions&gt;                &lt;/lifecycleMappingMetadata&gt;            &lt;/configuration&gt;        &lt;/plugin&gt;    &lt;/plugins&gt;&lt;/pluginManagement&gt;&lt;/build&gt;</code></pre><p>基于上面的Maven配置，运行<code>mvn generate-sources</code>生成客户端库代码到项目的target/generated-sources目录下，运行<code>mvn package</code>将会将生成的客户端库代码打包成一个jar包</p><h3 id="客户端调用"><a href="#客户端调用" class="headerlink" title="客户端调用"></a>客户端调用</h3><p>最后，我们就可以在应用项目中使用那个客户端库调用服务了</p><pre><code class="java">ApiClient apiClient = new ApiClient();apiClient.setBasePath(&quot;http://localhost:8080&quot;);CustomersApi customerApi = new CustomersApi(apiClient);List&lt;Customer&gt; customers = customerApi.getCustomers(&quot;peter&quot;, 40);</code></pre><p>通过上述调用代码，可以看出这大大的简化了调用RESTful服务的过程，这里我们使用抽象api的调用，非常低级的工作交给了客户端的lib完成</p><h2 id="博主声明"><a href="#博主声明" class="headerlink" title="博主声明"></a>博主声明</h2><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href="http://blog.philipphauer.de/enriching-restful-services-swagger/" target="_blank" rel="external">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p><p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;通常来说调用一个RESTful服务接口可以说是一个比较繁杂的事情,因为有很多非常低效的任务要去做。我们非常羡慕使用WS*/SOAP协议服务的人:他们可以很容易地基于正式的WSDL接口规范生成一个客户端API，这样大大的简化了服务的调用。在很长一段时间内REST世界中缺乏广泛的正式规范和生成工具。但是Swagger的出现改变了这种局面&lt;br&gt;
    
    </summary>
    
      <category term="随笔" scheme="http://www.jumpbyte.cn/categories/essay/"/>
    
    
      <category term="Swagger" scheme="http://www.jumpbyte.cn/tags/Swagger/"/>
    
      <category term="RESTful Service" scheme="http://www.jumpbyte.cn/tags/RESTful-Service/"/>
    
      <category term="原创翻译" scheme="http://www.jumpbyte.cn/tags/%E5%8E%9F%E5%88%9B%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot+SpringMVC4实现单文件多文件上传</title>
    <link href="http://www.jumpbyte.cn/2016/09/02/spring-4-mvc-single-multiple-file-upload-example-with-springboot/"/>
    <id>http://www.jumpbyte.cn/2016/09/02/spring-4-mvc-single-multiple-file-upload-example-with-springboot/</id>
    <published>2016-09-02T17:33:38.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<p>本文我们将学习如何在SpringMVC4中实现文件的上传，示例将提供单文件和多文件的上传的演示。使用更少的XML配置，我们将需要为文件上传配置一个MultipartConfigElement Bean对象，控制器中方法的参数应该使用MultipartFile类接受上传文件。同时在JSP页面表单，enctype属性要设置成多部分表单数据(multipart/form-data),现在来说下我们的示例代码<br><a id="more"></a></p><h3 id="开发工具"><a href="#开发工具" class="headerlink" title="开发工具"></a>开发工具</h3><p>  运行此示例我们需要准备好以下软件环境</p><ul><li>JDK7</li><li>Eclipse</li><li>Tomcat7</li><li>Gradle 2.0 for Spring Boot</li></ul><h3 id="Eclipse示例项目结构"><a href="#Eclipse示例项目结构" class="headerlink" title="Eclipse示例项目结构"></a>Eclipse示例项目结构</h3><p>为了更好的理解，我们先整体看下示例类文件和JSP页面的存放结构<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-2/15447753.jpg" alt=" Eclipse示例项目结构"></p><h3 id="控制器：使用MultipartFile类"><a href="#控制器：使用MultipartFile类" class="headerlink" title="控制器：使用MultipartFile类"></a>控制器：使用MultipartFile类</h3><p>本示例我们要演示单文件和多文件上传，所以我们创建了两个不同上传文件的方法。</p><p>单文件上传方法里需要包含有如下的一个参数：</p><pre><code class="Java">@RequestParam(&quot;file&quot;) MultipartFile file</code></pre><p>多文件上传方法中，方法参数如下：</p><pre><code class="java">@RequestParam(&quot;file&quot;) MultipartFile[]  file</code></pre><p>从MultipartFile对象中获取上传文件的名称保存到你期望保存路径位置，整个上传文件代码逻辑如下：</p><p><strong>文件清单：FileUploadController.java</strong></p><pre><code>package com.concretepage;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileOutputStream;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RequestParam;import org.springframework.web.bind.annotation.ResponseBody;import org.springframework.web.multipart.MultipartFile;@Controllerpublic class FileUploadController {    @RequestMapping(value=&quot;/singleUpload&quot;)    public String singleUpload(){        return &quot;singleUpload&quot;;    }    @RequestMapping(value=&quot;/singleSave&quot;, method=RequestMethod.POST )    public @ResponseBody String singleSave(@RequestParam(&quot;file&quot;) MultipartFile file, @RequestParam(&quot;desc&quot;) String desc ){        System.out.println(&quot;File Description:&quot;+desc);        String fileName = null;        if (!file.isEmpty()) {            try {                fileName = file.getOriginalFilename();                byte[] bytes = file.getBytes();                BufferedOutputStream buffStream =                        new BufferedOutputStream(new FileOutputStream(new File(&quot;F:/cp/&quot; + fileName)));                buffStream.write(bytes);                buffStream.close();                return &quot;You have successfully uploaded &quot; + fileName;            } catch (Exception e) {                return &quot;You failed to upload &quot; + fileName + &quot;: &quot; + e.getMessage();            }        } else {            return &quot;Unable to upload. File is empty.&quot;;        }    }    @RequestMapping(value=&quot;/multipleUpload&quot;)    public String multiUpload(){        return &quot;multipleUpload&quot;;    }    @RequestMapping(value=&quot;/multipleSave&quot;, method=RequestMethod.POST )    public @ResponseBody String multipleSave(@RequestParam(&quot;file&quot;) MultipartFile[] files){        String fileName = null;        String msg = &quot;&quot;;        if (files != null &amp;&amp; files.length &gt;0) {            for(int i =0 ;i&lt; files.length; i++){                try {                    fileName = files[i].getOriginalFilename();                    byte[] bytes = files[i].getBytes();                    BufferedOutputStream buffStream =                            new BufferedOutputStream(new FileOutputStream(new File(&quot;F:/cp/&quot; + fileName)));                    buffStream.write(bytes);                    buffStream.close();                    msg += &quot;You have successfully uploaded &quot; + fileName +&quot;&lt;br/&gt;&quot;;                } catch (Exception e) {                    return &quot;You failed to upload &quot; + fileName + &quot;: &quot; + e.getMessage() +&quot;&lt;br/&gt;&quot;;                }            }            return msg;        } else {            return &quot;Unable to upload. File is empty.&quot;;        }    }}</code></pre><h3 id="使用MultipartConfigElement上传配置类"><a href="#使用MultipartConfigElement上传配置类" class="headerlink" title="使用MultipartConfigElement上传配置类"></a>使用MultipartConfigElement上传配置类</h3><p>在配置代码里面,我们需要使用到MultipartConfigElement和UrlBasedViewResolver两个配置类。MultipartConfigElement支持文件上传，例如我们可以设置最大文件大小,最大请求大小等。MultipartConfigElement需要在WebApplicationInitializer中被配置到Dispatcher servlet中。UrlBasedViewResolver定义JSP位置和文件扩展名的输出模式</p><p><strong>代码清单：AppConfig.java</strong></p><pre><code>package com.concretepage;import javax.servlet.MultipartConfigElement;import org.springframework.boot.autoconfigure.EnableAutoConfiguration;import org.springframework.boot.context.embedded.MultipartConfigFactory;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.view.JstlView;import org.springframework.web.servlet.view.UrlBasedViewResolver;@Configuration@ComponentScan@EnableWebMvc@EnableAutoConfigurationpublic class AppConfig {    @Bean    public MultipartConfigElement multipartConfigElement() {        MultipartConfigFactory factory = new MultipartConfigFactory();        factory.setMaxFileSize(&quot;128KB&quot;);        factory.setMaxRequestSize(&quot;128KB&quot;);        return factory.createMultipartConfig();    }    @Bean      public UrlBasedViewResolver setupViewResolver() {          UrlBasedViewResolver resolver = new UrlBasedViewResolver();          resolver.setPrefix(&quot;/views/&quot;);          resolver.setSuffix(&quot;.jsp&quot;);          resolver.setViewClass(JstlView.class);        return resolver;      }}</code></pre><h3 id="WebApplicationInitializer初始化"><a href="#WebApplicationInitializer初始化" class="headerlink" title="WebApplicationInitializer初始化"></a>WebApplicationInitializer初始化</h3><p>WebApplicationInitializer使我们的应用程序不再依赖web.xml文件，也一样可以支持所有应用功能。为了支持文件上传，我们的dispatcher必须注入多文件上传配置类</p><p><strong>文件清单：WebAppInitializer.java</strong></p><pre><code>package com.concretepage;import javax.servlet.MultipartConfigElement;import javax.servlet.ServletContext;  import javax.servlet.ServletException;  import javax.servlet.ServletRegistration.Dynamic;  import org.springframework.web.WebApplicationInitializer;  import org.springframework.web.context.support.AnnotationConfigWebApplicationContext;  import org.springframework.web.servlet.DispatcherServlet;  public class WebAppInitializer implements WebApplicationInitializer {    public void onStartup(ServletContext servletContext) throws ServletException {          AnnotationConfigWebApplicationContext ctx = new AnnotationConfigWebApplicationContext();          ctx.register(AppConfig.class);          ctx.setServletContext(servletContext);        ctx.refresh();        Dynamic dynamic = servletContext.addServlet(&quot;dispatcher&quot;, new DispatcherServlet(ctx));          dynamic.addMapping(&quot;/&quot;);          dynamic.setLoadOnStartup(1);        dynamic.setMultipartConfig(ctx.getBean(MultipartConfigElement.class));   }  }</code></pre><h3 id="视图页面配置"><a href="#视图页面配置" class="headerlink" title="视图页面配置"></a>视图页面配置</h3><p>使用jsp视图，为了支持文件上传,必须设置enctype为多部分表单数据,并添加一个file输入框。我们有两个JSP，找到单文件上传的JSP页面如下<br><strong>文件清单：singleUpload.jsp</strong></p><pre><code>&lt;html&gt;&lt;body&gt;&lt;h1&gt;Single File Upload&lt;/h1&gt;    &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;singleSave&quot;&gt;        Upload File: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt;        &lt;br /&gt;&lt;br /&gt;        Description: &lt;input type=&quot;text&quot; name=&quot;desc&quot;/&gt;        &lt;br/&gt;&lt;br/&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><p>找到多文件上传JSP页面，我们需要注意每个file输入框name必须一致，这样可以在后台通过一个集合数组来访问<br><strong>文件清单：multipleUpload.jsp</strong></p><pre><code>&lt;html&gt;&lt;body&gt;    &lt;h1&gt; Multiple File Upload &lt;/h1&gt;    &lt;form method=&quot;post&quot; enctype=&quot;multipart/form-data&quot; action=&quot;multipleSave&quot;&gt;        Upload File 1: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;        Upload File 2: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;        Upload File 3: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;        Upload File 4: &lt;input type=&quot;file&quot; name=&quot;file&quot;&gt; &lt;br/&gt;        &lt;br /&gt;&lt;br /&gt;&lt;input type=&quot;submit&quot; value=&quot;Upload&quot;&gt;    &lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="使用Gradle管理Spring-Boot包依赖"><a href="#使用Gradle管理Spring-Boot包依赖" class="headerlink" title="使用Gradle管理Spring Boot包依赖"></a>使用Gradle管理Spring Boot包依赖</h3><p>在gradle脚本添加JAR依赖项，构建项目创建WAR文件。此示例用到了Spring boot web和security依赖<br><strong>文件清单：build.gradle</strong></p><pre><code>apply plugin: &#39;java&#39;apply plugin: &#39;eclipse&#39;apply plugin: &#39;war&#39;archivesBaseName = &#39;CP&#39;repositories {    mavenCentral()}dependencies {   compile &#39;org.springframework.boot:spring-boot-starter-web:1.1.4.RELEASE&#39;   compile &#39;org.springframework.boot:spring-boot-starter-security:1.1.4.RELEASE&#39;   compile &#39;javax.servlet:jstl:1.2&#39;   compile &#39;commons-fileupload:commons-fileupload:1.3.1&#39;}</code></pre><h3 id="Tomcat7部署示例运行"><a href="#Tomcat7部署示例运行" class="headerlink" title="Tomcat7部署示例运行"></a>Tomcat7部署示例运行</h3><p>到项目build目录，在lib下会得到一个war文件， 将此war部署到tomcat运行测试</p><p><strong>单个文件上传输出</strong></p><p>访问URL<a href="http://localhost:8080/CP/singleUpload" target="_blank" rel="external">http://localhost:8080/CP/singleUpload</a><br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-2/84536250.jpg" alt="单个文件上传"><br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-2/16535556.jpg" alt="单个文件上传]"></p><p><strong>多文件上传输出</strong><br>访问URL<a href="http://localhost:8080/CP/multipleUpload" target="_blank" rel="external">http://localhost:8080/CP/multipleUpload</a><br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-2/6931726.jpg" alt="多文件上传"><br><img src="http://oaefo3hoy.bkt.clouddn.com/16-9-2/8079858.jpg" alt="多文件上传"></p><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p><a href="http://www.concretepage.com/spring-4/download/spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip" target="_blank" rel="external">spring-4-mvc-single-multiple-file-upload-example-with-tomcat.zip</a></p><h3 id="博主声明"><a href="#博主声明" class="headerlink" title="博主声明"></a>博主声明</h3><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href="http://www.concretepage.com/spring-4/spring-4-mvc-single-multiple-file-upload-example-with-tomcat" target="_blank" rel="external">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p><p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文我们将学习如何在SpringMVC4中实现文件的上传，示例将提供单文件和多文件的上传的演示。使用更少的XML配置，我们将需要为文件上传配置一个MultipartConfigElement Bean对象，控制器中方法的参数应该使用MultipartFile类接受上传文件。同时在JSP页面表单，enctype属性要设置成多部分表单数据(multipart/form-data),现在来说下我们的示例代码&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.jumpbyte.cn/categories/SpringBoot/"/>
    
    
      <category term="java" scheme="http://www.jumpbyte.cn/tags/java/"/>
    
      <category term="原创翻译" scheme="http://www.jumpbyte.cn/tags/%E5%8E%9F%E5%88%9B%E7%BF%BB%E8%AF%91/"/>
    
      <category term="Spring Boot" scheme="http://www.jumpbyte.cn/tags/Spring-Boot/"/>
    
      <category term="文件上传" scheme="http://www.jumpbyte.cn/tags/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
    
      <category term="示例" scheme="http://www.jumpbyte.cn/tags/%E7%A4%BA%E4%BE%8B/"/>
    
  </entry>
  
  <entry>
    <title>基于Spring Boot运行Spring MVC 应用程序</title>
    <link href="http://www.jumpbyte.cn/2016/08/20/spring-boot-spring-mvc/"/>
    <id>http://www.jumpbyte.cn/2016/08/20/spring-boot-spring-mvc/</id>
    <published>2016-08-20T11:52:31.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本教程适合对于有兴趣学习Spring Boot如何结合Spring MVC一起开发的初学者。通过本教程,您可以使用Spring Boot运行一个简单的Spring MVC应用程序<br><a id="more"></a></p><blockquote><p>SpringBoot是一个Spring IO中的一个项目，它旨在减少Spring应用程序启动配置和连接。开发人员只专注于编写应用程序，SpringBoot将简化打包和部署的流程，而且不需要任何显示的声明配置。它就是如此在容器之外工作的! 在这里,我将解释如何使用Spring Boot运行一个简单且带有执行CRUD操作的Spring MVC应用程序。开始这个例子之前,请<a href="http://www.javabeat.net/maven-eclipse/" target="_blank" rel="external">在eclipse中创建web项目</a>。</p></blockquote><ul><li>扩展阅读:<a href="http://www.javabeat.net/spring-boot/" target="_blank" rel="external">http://www.javabeat.net/spring-boot/</a></li></ul><h3 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h3><p>我已经实现了一个例子，例子做了如下的工作</p><ol><li>创建一个Web 页面</li><li>用户可以想数据库中添加员工</li><li>用户可以在浏览器页面查看已添加到数据中的员工列表(JSON形式的结果)</li></ol><p>上面展现的工作使用到了Spring MVC, Hibernate and Spring Boot这些技术</p><h3 id="创建领域对象"><a href="#创建领域对象" class="headerlink" title="创建领域对象"></a>创建领域对象</h3><p>第一步，创建一个用来存储员工详细信息的Employee类，它是一个简单的POJO对象</p><pre><code class="java">@Entitypublic class Employee {    @Id    @NotNull    @Size(max = 64)    @Column(name = &quot;id&quot;, nullable = false, updatable = false)    private String id;    @NotNull    @Size(max = 64)    @Column(name = &quot;name&quot;, nullable = false)    private String name;    @NotNull    @Size(max = 64)    @Column(name = &quot;city&quot;, nullable = false)    private String city;    Employee() {    }    public Employee(final String id, final String name,final String city) {        this.id = id;        this.name = name;        this.city = city;    }    public String getId() {        return id;    }    public String getName() {        return name;    }    public void setName(String name) {        this.name = name;    }    public String getCity() {        return city;    }    public void setCity(String city) {        this.city = city;    }    @Override    public String toString() {        return Objects.toStringHelper(this)                .add(&quot;id&quot;, id)                .add(&quot;name&quot;, name)                .add(city, city)                .toString();    }}</code></pre><h3 id="创建Spring-Data-JPA仓库"><a href="#创建Spring-Data-JPA仓库" class="headerlink" title="创建Spring Data JPA仓库"></a>创建Spring Data JPA仓库</h3><p>Spring Data JPA是一个非常简单的方法保存数据到后端，如果你看了下面的代码，这就是你要持久化员工类将要写的代码，Spring Data在内部为你实现了必要的类和CRUD的操作，你只需要像下面一样提供一个接口即可，如果你对于Spring Data有兴趣，请阅读我们的<a href="http://www.javabeat.net/spring-data-jpa-tutorial/" target="_blank" rel="external">Spring Data JPA教程</a></p><pre><code>public interface EmployeeRepository extends JpaRepository&lt;Employee, String&gt; {}</code></pre><h3 id="创建服务的实现类"><a href="#创建服务的实现类" class="headerlink" title="创建服务的实现类"></a>创建服务的实现类</h3><pre><code class="java">@Service@Validatedpublic class EmployeeServiceImpl implements EmployeeService {    private static final Logger LOGGER = LoggerFactory.getLogger(EmployeeServiceImpl.class);    private final EmployeeRepository repository;    @Inject    public EmployeeServiceImpl(final EmployeeRepository repository) {        this.repository = repository;    }    @Transactional    public Employee save(@NotNull @Valid final Employee employee) {        LOGGER.debug(&quot;Creating {}&quot;, employee);        return repository.save(employee);    }    @Transactional(readOnly = true)    public List&lt;Employee&gt; getList() {        LOGGER.debug(&quot;Retrieving the list of all users&quot;);        return repository.findAll();    }}</code></pre><h3 id="创建SpringMVC控制器"><a href="#创建SpringMVC控制器" class="headerlink" title="创建SpringMVC控制器"></a>创建SpringMVC控制器</h3><p>这里对于Spring的开发者来说没有任何新的特性，我们只是创建一个简单实现了对员工的详细信息的添加和列表浏览</p><pre><code>@RestControllerpublic class EmployeeController {    private final EmployeeService employeeService;    @Inject    public EmployeeController(final EmployeeService employeeService) {        this.employeeService = employeeService;    }    @RequestMapping(value = &quot;/employee&quot;, method = RequestMethod.GET)    public List&lt;Employee&gt; listEmployees() {        List&lt;Employee&gt; employees = employeeService.getList();        return employees;    }    @RequestMapping(value=&quot;/add&quot;,method = RequestMethod.GET)    public void addEmployee(@RequestParam(value = &quot;employeeName&quot;, required = false) String employeeName,            @RequestParam(value = &quot;employeeId&quot;, required = false) String employeeId,            @RequestParam(value = &quot;employeeCity&quot;, required = false) String employeeCity){        Employee employee = new Employee(employeeId,employeeName,employeeCity);        employeeService.save(employee);    }}</code></pre><h3 id="创建JSP页面"><a href="#创建JSP页面" class="headerlink" title="创建JSP页面"></a>创建JSP页面</h3><pre><code>&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;    &lt;title&gt;Hello WebSocket&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;/add&quot;&gt;    &lt;input type=&quot;input&quot; name=&quot;employeeName&quot;&gt;    &lt;input type=&quot;input&quot; name=&quot;employeeId&quot;&gt;    &lt;input type=&quot;input&quot; name=&quot;employeeCity&quot;&gt;    &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;/body&gt;&lt;/html&gt;</code></pre><h3 id="Spring-Boot-应用程序"><a href="#Spring-Boot-应用程序" class="headerlink" title="Spring Boot 应用程序"></a>Spring Boot 应用程序</h3><p>最后，我们需要写一个Spring Boot application来运行我们的示例，这是一个主应用程序，当你试图执行应用程序时，它将会被SpringBoot调用</p><ul><li>扩展阅读:<a href="http://www.javabeat.net/restful-springboot-mongodb/" target="_blank" rel="external">REStful API using Spring Boot</a></li></ul><pre><code>@Configuration@EnableAutoConfiguration@ComponentScanpublic class Application extends SpringBootServletInitializer {    public static void main(final String[] args) {        SpringApplication.run(Application.class, args);    }    @Override    protected final SpringApplicationBuilder configure(final SpringApplicationBuilder application) {        return application.sources(Application.class);    }}</code></pre><p><strong>@EnableAutoConfiguration</strong></p><p>这个注解会试图在类路径下去查找启动应用程序所必需的beans，例如，如果你在类路径下有一个tomcat-embedded.jar，你可能会需要一个TomcatEmbeddedServletContainerFactory，这个包下的这个类被@EnableAutoConfiguration注解就有特殊的意义，通常会被作为默认的使用。再比如，当扫描带有@Entity注解的类它将被用到。通常推荐的做法，你可以在一个包的根下使用@EnableAutoConfiguration注解，这样所有子包和类都会被搜索</p><p><strong>SpringApplication.run()</strong></p><p>SpringApplication类是用于引导和启动Spring应用程序的。引导一个Spring应用程序创建适当的应用程序上下文，加载beans，触发任何命令式的bean对象等</p><p><strong>SpringBootServletInitializer</strong></p><p>这个是运行web应用所必须的，它将打开一个 servlet 容器，并将你的应用绑定到此容器内。</p><h3 id="MAVEN配置"><a href="#MAVEN配置" class="headerlink" title="MAVEN配置"></a>MAVEN配置</h3><p>这个运行SpringBoot应用非常重要的环节。SpringBoot需要通过在构建脚本文件中确定运行应用程序的包依赖，它能支持各种各样的构建工具，但SpringBoot官方文档中重点强调使用Maven和Gradle配置，因此，明智的做法是选择其中任何一个去简单的实现</p><p>这里是使用maven配置如下：</p><pre><code class="xml">&lt;dependencies&gt;       &lt;!-- Spring Boot --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;           &lt;scope&gt;test&lt;/scope&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;           &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- Hibernate validator --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.hibernate&lt;/groupId&gt;           &lt;artifactId&gt;hibernate-validator&lt;/artifactId&gt;       &lt;/dependency&gt;       &lt;!-- HSQLDB --&gt;       &lt;dependency&gt;           &lt;groupId&gt;org.hsqldb&lt;/groupId&gt;           &lt;artifactId&gt;hsqldb&lt;/artifactId&gt;           &lt;scope&gt;runtime&lt;/scope&gt;       &lt;/dependency&gt;       &lt;!-- Guava --&gt;       &lt;dependency&gt;           &lt;groupId&gt;com.google.guava&lt;/groupId&gt;           &lt;artifactId&gt;guava&lt;/artifactId&gt;           &lt;version&gt;${guava.version}&lt;/version&gt;       &lt;/dependency&gt;       &lt;!-- Java EE --&gt;       &lt;dependency&gt;           &lt;groupId&gt;javax.inject&lt;/groupId&gt;           &lt;artifactId&gt;javax.inject&lt;/artifactId&gt;           &lt;version&gt;1&lt;/version&gt;       &lt;/dependency&gt;   &lt;/dependencies&gt;   &lt;build&gt;       &lt;plugins&gt;           &lt;!-- Spring Boot Maven --&gt;           &lt;plugin&gt;               &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;               &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt;           &lt;/plugin&gt;       &lt;/plugins&gt;   &lt;/build&gt;</code></pre><p><strong>spring-boot-starter-*</strong></p><p>Starter POM是预定义的作为内置可用的POM集合描述，你不需要去搜索和配置那些依赖。比如，如果你正在为数据访问寻找Spring和JPA依赖，你只需把spring-boot-starter-data-jpa包含到你的POM文件中即可</p><p><strong>spring-boot-maven-plugin</strong></p><p>这个插件允许你将应用程序打包成一个可执行的JAR或WAR文件，它支持Maven 3.2以上版本。在我们的示例，当你使用“mvn install”命令运行项目，maven将构建此项目并且会在target目录创建一个可执行的JAR文件。</p><p><strong>spring-boot-starter-parent</strong></p><p>如果你想从spring-boot-starter-parent继承属性,然后简单地设置此父项目。如果你使用此父项目,版本号可以省略其他starters POM也如此。如果你有你自己的项目为你的项目,那么你可以使用它们代替由SpringBoot默认提供的父项目。配置如下：</p><pre><code class="xml">&lt;parent&gt;    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;    &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;    &lt;version&gt;1.0.1.RELEASE&lt;/version&gt;&lt;/parent&gt;</code></pre><h3 id="最终项目结构"><a href="#最终项目结构" class="headerlink" title="最终项目结构"></a>最终项目结构</h3><p>下面图是最终项目的包结构，这里我已经在一个包下面创建了一个Application.java。但好的实践是把这个文件直接放到包的根目录下<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-20/18274027.jpg" alt="最终项目的包结构"></p><h3 id="运行SpringBoot可执行Jar包"><a href="#运行SpringBoot可执行Jar包" class="headerlink" title="运行SpringBoot可执行Jar包"></a>运行SpringBoot可执行Jar包</h3><p>一旦你创建好了应用程序，运行这个命令来执行应用程序</p><pre><code>java -jar target/mymodule-0.0.1-SNAPSHOT.jar</code></pre><p>在你命令行程序运行上面的命令后，SpringBoot应用会在<a href="http://localhost:8080/" target="_blank" rel="external">http://localhost:8080/</a>运行此程序。你可以通过<a href="http://localhost:8080/index.jsp" target="_blank" rel="external">http://localhost:8080/index.jsp</a>访问应用的首页<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-20/78731535.jpg" alt="访问应用的首页"></p><p>你可以添加很多行员工数据，当你访问<a href="http://localhost:8080/employee" target="_blank" rel="external">http://localhost:8080/employee</a>,你会在浏览器窗口看到类似下面的输出</p><pre><code>[{&quot;id&quot;:&quot;Krishna&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;},{&quot;id&quot;:&quot;Manisha Patil&quot;,&quot;name&quot;:&quot;005&quot;,&quot;city&quot;:&quot;Pune&quot;},{&quot;id&quot;:&quot;Sanulla&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;},{&quot;id&quot;:&quot;Shunmuga Raja&quot;,&quot;name&quot;:&quot;001&quot;,&quot;city&quot;:&quot;Bangalore&quot;}]</code></pre><h3 id="源码下载"><a href="#源码下载" class="headerlink" title="源码下载"></a>源码下载</h3><p><a href="http://javabeat.net/download/spring-boot-spring-mvc/?wpdmdl=22124" target="_blank" rel="external">Spring Boot Spring MVC</a></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>在本文中,我们已经讨论了如何创建一个maven项目和创建员工所需的不同组件管理Spring MVC应用程序。后来我们已经探讨了SpringBoot配置细节和SpringBoot应用所需的Maven POM文件内容。最后我们已经讨论了运行一个通过Maven打包生成可执行JAR文件。在本教程中,您将能够了解关于SpringBoot和Spring MVC是怎样一起工作</p><h3 id="博主声明"><a href="#博主声明" class="headerlink" title="博主声明"></a>博主声明</h3><p>本文属于博主原创英文技术文章翻译，原文连接请点击<a href="http://javabeat.net/spring-boot-spring-mvc/" target="_blank" rel="external">这里</a>,翻译过程博主对原文会加入自己的理解，文章结构也会有稍微调整以更适合阅读</p><p>由于翻译和理解能力有限，文章难免会存在一定瑕疵希望读者见谅，如有任何错误纰漏欢迎在下方评论指正，谢谢！</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本教程适合对于有兴趣学习Spring Boot如何结合Spring MVC一起开发的初学者。通过本教程,您可以使用Spring Boot运行一个简单的Spring MVC应用程序&lt;br&gt;
    
    </summary>
    
      <category term="SpringBoot" scheme="http://www.jumpbyte.cn/categories/SpringBoot/"/>
    
    
      <category term="原创翻译" scheme="http://www.jumpbyte.cn/tags/%E5%8E%9F%E5%88%9B%E7%BF%BB%E8%AF%91/"/>
    
      <category term="SpringBoot" scheme="http://www.jumpbyte.cn/tags/SpringBoot/"/>
    
      <category term="Java" scheme="http://www.jumpbyte.cn/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>在windows,linux下搭建zookeeper集群环境</title>
    <link href="http://www.jumpbyte.cn/2016/08/13/zookeeper-install-deploy/"/>
    <id>http://www.jumpbyte.cn/2016/08/13/zookeeper-install-deploy/</id>
    <published>2016-08-13T17:56:29.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Zookeeper简介"><a href="#Zookeeper简介" class="headerlink" title="Zookeeper简介"></a>Zookeeper简介</h2><p>Zookeeper是一个分布式服务框架，它是 Apache Hadoop 的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将介绍Zookeeper如何在windows和linux下的进行集群部署，以便为我们使用zookeeper的相关功能做好环境支持</p><a id="more"></a><h2 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h2><p>zookeeper本身要依赖java jdk环境，在搭建前需要确认你的系统安装了java jdk，并配置好了jdk环境变量</p><h2 id="win下搭建zookeeper集群"><a href="#win下搭建zookeeper集群" class="headerlink" title="win下搭建zookeeper集群"></a>win下搭建zookeeper集群</h2><p>由于机器有限，本次教程准备在单台机器搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境</p><h3 id="安装包下载"><a href="#安装包下载" class="headerlink" title="安装包下载"></a>安装包下载</h3><p>访问<a href="https://zookeeper.apache.org/" title="zookeeper官网" target="_blank" rel="external">https://zookeeper.apache.org/</a>找到并下载我们需要安装的版本，这里我选择下载<a href="http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz" target="_blank" rel="external">zookeeper 3.4.6版本</a>(注：zookeeper安装包不区分操作系统平台)</p><h3 id="安装包解压，集群节点建立"><a href="#安装包解压，集群节点建立" class="headerlink" title="安装包解压，集群节点建立"></a>安装包解压，集群节点建立</h3><ol><li><p>创建集群目录如<code>D:\ProgramFiles\zk_cluster</code>,并在集群目录下创建三个目录s1,s2,s3，代表三个zookeeper集群节点，如图:<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-13/78596671.jpg" alt="三个zookeeper节点目录"></p></li><li><p>将下载的安装包解压到指定zookeeper节点目录，本教程我先解压到上文中新建的s1目录(D:\ProgramFiles\zk_cluster\s1),并重命名zookeeper-3.4.6为zookeeper</p></li><li><p>在s1目录(D:\ProgramFiles\zk_cluster\s1)新建data和dataLog两个目录(下文配置会用到)，最终s1目录结构如图：<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-13/9287916.jpg" alt="s1目录结构"></p></li></ol><h3 id="配置zoo-cfg文件参数"><a href="#配置zoo-cfg文件参数" class="headerlink" title="配置zoo.cfg文件参数"></a>配置zoo.cfg文件参数</h3><p>在目录D:\ProgramFiles\zk_cluster\s1\zookeeper\conf 有一个zoo_sample.cfg文件，先将其重命名或者复制为zoo.cfg(zookeeper在启动时会找这个文件作为默认配置文件),然后修改zoo.cfg为如下内容(<a href="#zoo_cfg_table">zoo.cfg各个配置参数的含义</a>)</p><pre><code>tickTime=2000initLimit=10syncLimit=5dataDir=D:\\ProgramFiles\\zk_cluster\\s1\\datadataLogDir=D:\\ProgramFiles\\zk_cluster\\s1\\dataLogclientPort=2181autopurge.snapRetainCount=3autopurge.purgeInterval=1server.1=127.0.0.1:2887:3887server.2=127.0.0.1:2888:3888server.3=127.0.0.1:2889:3889</code></pre><p>除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。</p><p>通过上述步骤，我们s1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将s1节点目录下面的所有内容分别复制到s2,s3节点目录下然后做如下调整</p><ol><li>修改s2,s3各自myid文件内容<br>s2\data\myid –&gt;2<br>s3\data\myid –&gt;3</li><li>修改s2,s3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数<br>s2节点的zoo.cfg修改的内容如下<pre><code>dataDir=D:\\ProgramFiles\\zk_cluster\\s2\\datadataLogDir=D:\\ProgramFiles\\zk_cluster\\s2\\dataLogclientPort=2182</code></pre>s3节点的zoo.cfg修改的内容如下<pre><code>dataDir=D:\\ProgramFiles\\zk_cluster\\s3\\datadataLogDir=D:\\ProgramFiles\\zk_cluster\\s3\\dataLogclientPort=2183</code></pre></li></ol><h3 id="启动集群中各个节点"><a href="#启动集群中各个节点" class="headerlink" title="启动集群中各个节点"></a>启动集群中各个节点</h3><p>到此为止，我们所有节点配置已经完成，接下来在每个节点目录zookeeper/bin目录都有一个zkServer.cmd脚本，分别双击对应脚本，即可以启动每个节点，所有节点启动后，此时会看到集群节点建立的信息，如下图，从图中我们可以看到集群正常启动，s2为集群的Leader,s1、s3为Flower节点<br><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-13/11539405.jpg" alt="集群节点"></p><p>如果觉得每次都要到对应节点下启动各自zkServer.cmd麻烦的话，我们可以做一个bat脚本来批量执行各自节点的zkServer.cmd；如我在D:\ProgramFiles\zk_cluster添加了一个zk_cluster_start.bat，内容如下，这样可以快速启动集群节点</p><pre><code class="shell">start cmd /c call %~dp0%s1\zookeeper\bin\zkServer.cmdstart cmd /c call %~dp0%s2\zookeeper\bin\zkServer.cmdstart cmd /c call %~dp0%s3\zookeeper\bin\zkServer.cmd</code></pre><h3 id="测试集群"><a href="#测试集群" class="headerlink" title="测试集群"></a>测试集群</h3><p>打开cmd窗口，切换到任意节点目录下zookeeper/bin, 输入zkCli.cmd -server host:port 连接集群任意节点测试，下面是我测试的结果,通过测试结果可以看出我们的集群可以正常工作，集群环境搭建成功</p><pre><code>D:\ProgramFiles\zk_cluster\s1\zookeeper\bin&gt;zkCli.cmd -server 127.0.0.1:2183...省略连接内容...[zk: 127.0.0.1:2183(CONNECTED) 1] create  /test1  aaaaCreated /test1[zk: 127.0.0.1:2183(CONNECTED) 5] connect 127.0.0.1:2181...省略连接内容...[zk: 127.0.0.1:2181(CONNECTED) 0] get /test1aaaacZxid = 0x700000006ctime = Sat Aug 13 21:44:50 CST 2016mZxid = 0x700000006mtime = Sat Aug 13 21:44:50 CST 2016pZxid = 0x700000006cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 4numChildren = 0[zk: 127.0.0.1:2181(CONNECTED) 1]</code></pre><p>windows上搭建zookeeper集群环境部署完毕！</p><h2 id="linux下搭建zookeeper集群"><a href="#linux下搭建zookeeper集群" class="headerlink" title="linux下搭建zookeeper集群"></a>linux下搭建zookeeper集群</h2><p>由于机器有限，本次教程准备在单台centos6.5虚拟机搭建三个zookeeper节点(集群节点至少为三个)，来模拟zookeeper集群环境</p><h3 id="安装包下载解压"><a href="#安装包下载解压" class="headerlink" title="安装包下载解压"></a>安装包下载解压</h3><p>进入shell命令窗口,将安装包下载到/usr/local/src目录，zookeeper版本同样使用<a href="http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz" target="_blank" rel="external">3.4.6版本</a></p><pre><code class="bash">[root@centos ~]# cd /usr/local/src[root@centos src]# wget http://apache.org/dist/zookeeper/zookeeper-3.4.6/zookeeper-3.4.6.tar.gz[root@centos src]# tar -zxvf zookeeper-3.4.6.tar.gz[root@centos src]# ll总用量 21332-rw-r--r--.  1 root root   392756 8月  10 11:31 man-db-2.7.5-3-x86_64.pkg.tar.xz-rw-r--r--.  1 root root   909077 8月  10 09:21 nginx-1.10.1.tar.gzdrwxrwxr-x.  6 root root     4096 4月   1 2015 redis-3.0.0-rw-r--r--.  1 root root  1358081 4月   1 2015 redis-3.0.0.tar.gzdrwxr-xr-x. 14 root root     4096 8月  10 11:07 xz-5.2.2-rw-r--r--.  1 root root  1464228 8月  10 11:04 xz-5.2.2.tar.gzdrwxr-xr-x. 10 1000 1000     4096 8月   8 11:13 zookeeper-3.4.6-rw-r--r--.  1 root root 17699306 8月   8 10:54 zookeeper-3.4.6.tar.gz</code></pre><h3 id="配置安装目录及环境变量"><a href="#配置安装目录及环境变量" class="headerlink" title="配置安装目录及环境变量"></a>配置安装目录及环境变量</h3><pre><code>[root@centos src] ln -s zookeeper-3.4.6  /usr/local/zookeeper</code></pre><p>这里我将zookeeper软连接到/usr/local/zookeeper下面，以后升级zookeeper版本可以不用修改让任何环境变量，直接更改软连接指向就可以完成升级</p><p>配置环境变量<br>vi 编辑/etc/profile文件，导入ZK_HOME环境变量，路径指向刚才的软连接目录，如下：</p><pre><code>#export env pathexport JAVA_HOME=/usr/local/java/jdkexport PATH=$PATH:$JAVA_HOME/bin:$JAVA_HOME/jre/bin:$PATHexport CLASSPATH=.:$JAVA_HOME/lib:$JAVA_HOME/jre/libexport PATH=$PATH:$CLASSPATHexport ZK_HOME=/usr/local/zookeeperexport PATH=$PATH:$ZK_HOME/binfor i in /etc/profile.d/*.sh ; do    if [ -r &quot;$i&quot; ]; then        if [ &quot;${-#*i}&quot; != &quot;$-&quot; ]; then            . &quot;$i&quot;        else            . &quot;$i&quot; &gt;/dev/null 2&gt;&amp;1        fi    fidoneunset iunset -f pathmunge</code></pre><p>这里注意jdk环境变量和zookeeper环境变量，要配置在第8行的上面，因为下文我们的登录自动启动脚本会放到/etc/profile.d/下，所以要在脚本执行前导入环境变量</p><h3 id="配置集群节点"><a href="#配置集群节点" class="headerlink" title="配置集群节点"></a>配置集群节点</h3><p>创建集群目录</p><ol><li>在/usr/local目录创建zookeeper_cluster目录，然后在zookeeper_cluster目录先创建一个集群节点目录server1</li><li>在server1目录创建data,logs目录</li><li>最后将/usr/local/zookeeper/conf/zoo_sample.cfg 拷贝重命名为zoo.cfg到server1目录</li></ol><p>操作过程如下</p><pre><code>[root@centos local]# mkdir zookeeper_cluster[root@centos local]# cd zookeeper_cluster[root@centos zookeeper_cluster]# mkdir server1[root@centos zookeeper_cluster]# cd server1[root@centos server1]# mkdir data logs[root@centos server1]# cp /usr/local/zookeeper/conf/zoo_sample.cfg zoo.cfg</code></pre><p>配置zoo.cfg文件参数</p><p>修改server1节点目录下zoo.cfg文件的内容(<a href="#zoo_cfg_table">zoo.cfg各个配置参数的含义</a>)</p><pre><code>[root@centos server1]# vi zoo.cfg</code></pre><p>内容修改如下</p><pre><code>tickTime=2000initLimit=10syncLimit=5dataDir=/usr/local/zookeeper_cluster/server1/datadataLogDir=/usr/local/zookeeper_cluster/server1/logsclientPort=2181autopurge.snapRetainCount=3autopurge.purgeInterval=1server.1=127.0.0.1:2887:3887server.2=127.0.0.1:2888:3888server.3=127.0.0.1:2889:3889</code></pre><p>创建myid文件</p><p>除了修改zoo.cfg配置文件，集群模式下我们还要在上面dataDir指定的目录创建一个文件myid，文件内容为一个数字1，Zookeeper启动时会读取这个文件，拿到里面的数字匹配zoo.cfg中server.1，从而判断那个是当前的server。</p><pre><code>[root@centos server1]# echo 1 &gt; data/myid</code></pre><p>配置另外两个节点</p><p>通过上述步骤，我们server1节点配置就已经完成了，接着我们可以按照同样的思路配置其他两个节点，为了方便，我们直接将server1节点目录复制为server2,server3</p><pre><code>[root@centos zookeeper_cluster] cp -rf server1  server2[root@centos zookeeper_cluster] cp -rf server1  server3</code></pre><ol><li>修改server2,server3各自myid文件内容<pre><code>[root@centos zookeeper_cluster] echo 2 &gt; server2/myid[root@centos zookeeper_cluster] echo 3 &gt; server3/myid</code></pre></li><li>修改server2,server3各自的zoo.cfg配置参数，主要修改dataDir,dataLogDir对应到各自相应的目录,因为是单机模式，为了防止端口冲突，也需要修改clientPort参数<br>server2节点zoo.cfg修改内容如下<pre><code>dataDir=/usr/local/zookeeper_cluster/server2/datadataLogDir=/usr/local/zookeeper_cluster/server2/logsclientPort=2182</code></pre>server3节点zoo.cfg修改内容如下<pre><code>dataDir=/usr/local/zookeeper_cluster/server3/datadataLogDir=/usr/local/zookeeper_cluster/server3/logsclientPort=2183</code></pre></li></ol><h3 id="启动集群"><a href="#启动集群" class="headerlink" title="启动集群"></a>启动集群</h3><p>这里我们先在/etc/profile.d/ 创建一个集群启动的脚本zk_cluster_strat.sh，脚本内容如下：</p><pre><code> #!/bin/bash #description:auto start zookeeper cluster nodes when user login zkServer.sh start  /usr/local/zookeeper_cluster/server1/zoo.cfg zkServer.sh start  /usr/local/zookeeper_cluster/server2/zoo.cfg zkServer.sh start  /usr/local/zookeeper_cluster/server3/zoo.cfg</code></pre><p> 脚本创建好之后，我们来手动执行下此脚本</p><pre><code>[root@centos ~]# .  /etc/profile.d/zk_cluster_start.shJMX enabled by defaultUsing config: /usr/local/zookeeper_cluster/server1/zoo.cfgStarting zookeeper ... STARTEDJMX enabled by defaultUsing config: /usr/local/zookeeper_cluster/server2/zoo.cfgStarting zookeeper ... STARTEDJMX enabled by defaultUsing config: /usr/local/zookeeper_cluster/server3/zoo.cfgStarting zookeeper ... STARTED</code></pre><h3 id="测试集群-1"><a href="#测试集群-1" class="headerlink" title="测试集群"></a>测试集群</h3><p>接着我们用zkCli.sh测试每个节点连接</p><pre><code>[root@centos ~]# zkCli.sh -server 127.0.0.1:2181省略连接内容...[zk: 127.0.0.1:2181(CONNECTED) 0] create /test  hello,world! #创建一个节点目录Created /test[zk: 127.0.0.1:2181(CONNECTED) 0] connect 127.0.0.1:2182省略连接内容...[zk: 127.0.0.1:2182(CONNECTED) 4] get /test  #获取刚才在127.0.0.1:2181创建/test节点内容hello,world!cZxid = 0x900000002ctime = Sun Aug 14 11:51:05 CST 2016mZxid = 0x900000002mtime = Sun Aug 14 11:51:05 CST 2016pZxid = 0x900000002cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 12numChildren = 0127.0.0.1:2181[zk: 127.0.0.1:2182(CONNECTED) 5] connect 127.0.0.1:2183省略连接内容...[zk: 127.0.0.1:2183(CONNECTED) 2] get /test #获取刚才在127.0.0.1:2181创建/test节点内容hello,world!cZxid = 0x900000002ctime = Sun Aug 14 11:51:05 CST 2016mZxid = 0x900000002mtime = Sun Aug 14 11:51:05 CST 2016pZxid = 0x900000002cversion = 0dataVersion = 0aclVersion = 0ephemeralOwner = 0x0dataLength = 12numChildren = 0</code></pre><p>linux上搭建zookeeper集群环境部署完毕！</p><hr><h2 id="zoo-cfg各个配置参数的含义"><a href="#zoo-cfg各个配置参数的含义" class="headerlink" title="zoo.cfg各个配置参数的含义"></a><span id="zoo_cfg_table">zoo.cfg各个配置参数的含义</span></h2><table><thead><tr><th style="text-align:center">配置参数</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:center"><strong>tickTime</strong></td><td style="text-align:left">这个时间是作为 Zookeeper 服务器之间或客户端与服务器之间维持心跳的时间间隔，也就是每个tickTime时间就会发送一个心跳。</td></tr><tr><td style="text-align:center"><strong>initLimit</strong></td><td style="text-align:left">这个配置项是用来配置Zookeeper接受客户端（这里所说的客户端不是用户连接Zookeeper服务器的客户端，而是Zookeeper服务器集群中连接到Leader的Follower服务器）初始化连接时最长能忍受多少个心跳时间间隔数。当已经超过10个心跳的时间（也就是tickTime）长度后Zookeeper服务器还没有收到客户端的返回信息，那么表明这个客户端连接失败。总的时间长度就是5*2000=10秒</td></tr><tr><td style="text-align:center"><strong>syncLimit</strong></td><td style="text-align:left">这个配置项标识Leader与Follower之间发送消息，请求和应答时间长度，最长不能超过多少个 tickTime 的时间长度，总的时间长度就2*2000=4 秒</td></tr><tr><td style="text-align:center"><strong>dataDir</strong></td><td style="text-align:left">顾名思义就是Zookeeper保存数据的目录，默认情况下，Zookeeper将写数据的日志文件也保存在这个目录里。</td></tr><tr><td style="text-align:center"><strong>dataLogDir</strong></td><td style="text-align:left">顾名思义就是Zookeeper记录数据变化的日志目录，如果不配置，默认日志文件会保存到dataDir数据目录中。</td></tr><tr><td style="text-align:center"><strong>clientPort</strong></td><td style="text-align:left">这个端口就是客户端连接Zookeeper服务器的端口，Zookeeper会监听这个端口，接受客户端的访问请求。</td></tr><tr><td style="text-align:center"><strong>autopurge.snapRetainCount</strong></td><td style="text-align:left">指定了需要保留的快照文件数目。默认是保留3个，需要和autopurge.purgeInterval搭配使用。</td></tr><tr><td style="text-align:center"><strong>autopurge.purgeInterval</strong></td><td style="text-align:left">指定了自动清理快照和事务日志的频率，单位是小时，需要填写一个1或更大的整数，默认是0，表示不开启自己清理功能</td></tr><tr><td style="text-align:center"><strong>server.A=B：C：D</strong></td><td style="text-align:left">其中A是一个数字，表示这个是第几号服务器；B是这个服务器的ip地址；C表示的是这个服务器与集群中的Leader服务器交换信息的端口；D 表示的是万一集群中的Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。如果是伪集群的配置方式，由于B都是一样，所以不同的Zookeeper实例通信端口号不能一样，所以要给它们分配不同的端口号。</td></tr></tbody></table><h2 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h2><ol><li><a href="http://www.ibm.com/developerworks/cn/data/library/bd-zookeeper/" target="_blank" rel="external">ZooKeeper 基础知识、部署和应用程序</a></li><li><a href="https://www.ibm.com/developerworks/cn/opensource/os-cn-zookeeper/" target="_blank" rel="external">分布式服务框架 Zookeeper – 管理分布式环境中的数据</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;Zookeeper简介&quot;&gt;&lt;a href=&quot;#Zookeeper简介&quot; class=&quot;headerlink&quot; title=&quot;Zookeeper简介&quot;&gt;&lt;/a&gt;Zookeeper简介&lt;/h2&gt;&lt;p&gt;Zookeeper是一个分布式服务框架，它是 Apache Hadoop 的一个子项目，主要是用来解决分布式应用中经常遇到的一些数据管理问题，如：统一命名服务、状态同步服务、集群管理、分布式应用配置项的管理等。本文将介绍Zookeeper如何在windows和linux下的进行集群部署，以便为我们使用zookeeper的相关功能做好环境支持&lt;/p&gt;
    
    </summary>
    
      <category term="安装部署" scheme="http://www.jumpbyte.cn/categories/%E5%AE%89%E8%A3%85%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="zookeeper" scheme="http://www.jumpbyte.cn/tags/zookeeper/"/>
    
      <category term="教程" scheme="http://www.jumpbyte.cn/tags/%E6%95%99%E7%A8%8B/"/>
    
      <category term="环境搭建" scheme="http://www.jumpbyte.cn/tags/%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    
  </entry>
  
  <entry>
    <title>linux命令拾遗(1)-whatis info man which whereis</title>
    <link href="http://www.jumpbyte.cn/2016/08/07/linux%E5%91%BD%E4%BB%A4%E6%8B%BE%E9%81%97-1/"/>
    <id>http://www.jumpbyte.cn/2016/08/07/linux命令拾遗-1/</id>
    <published>2016-08-07T14:47:17.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h3><p>接触和学习过linux的同学相比都知道linux命令的繁多和复杂，无论是linux初学者还是老司机，也不可能把所有linux的命令都记住，好在linux有一一些强大的帮助命令，让我们不用担心不熟悉或者暂时遗忘的命令的情况，下面我们来看怎么去正确的使用这些命令<br><a id="more"></a></p><blockquote><ol><li>在只记得部分关键字的时候，可以通过man -k 来搜索</li><li>查看某个命令的简单功能描述，可以通过whatis</li><li>查看某个命令更详细的说明可以用info 命令</li><li>要查看某个命令的具体位置，可以使用which</li><li>对于要查看某个命令的具体参数的含义及使用方法，可以借助强大的man命令</li></ol></blockquote><h3 id="whatis"><a href="#whatis" class="headerlink" title="whatis"></a>whatis</h3><p>whatis命令是用于查询一个命令执行什么功能，并将查询结果打印到终端上</p><blockquote><p>whatis命令在用catman -w命令创建的数据库中查找command参数指定的命令、系统调用、库函数或特殊文件名。whatis命令显示手册部分的页眉行。然后可以发出man命令以获取附加的信息。whatis命令等同于使用man -f命令</p></blockquote><h4 id="用法"><a href="#用法" class="headerlink" title="用法"></a>用法</h4><pre><code>whatis 命令名称</code></pre><h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><pre><code>[root@centos etc]# whatis cpcp                   (1)  - copy files and directories[root@centos etc]# whatis lsls                   (1)  - list directory contents[root@centos etc]# whatis chownchown                (1)  - change file owner and group[root@centos etc]# whatis rmrm                   (1)  - remove files or directories</code></pre><h3 id="info"><a href="#info" class="headerlink" title="info"></a>info</h3><p>查看某个命令更详细的说明</p><blockquote><p>就内容来说，info页面比man page编写得要更好、更容易理解，也更友好，但man page使用起来确实要更容易得多。一个man page只有一页，而info页面几乎总是将它们的内容组织成多个区段（称为节点），每个区段也可能包含子区段（称为子节点）。理解这个命令的窍门就是不仅要学习如何在单独的Info页面中浏览导航，还要学习如何在节点和子节点之间切换。可能刚开始会一时很难在info页面的节点之间移动和找到你要的东西，真是具有讽刺意味：原本以为对于新手来说，某个东西比man命令会更好些，但实际上学习和使用起来更困难。</p></blockquote><h4 id="用法-1"><a href="#用法-1" class="headerlink" title="用法"></a>用法</h4><pre><code>info [选项] [参数]</code></pre><h4 id="选项列举"><a href="#选项列举" class="headerlink" title="选项列举"></a>选项列举</h4><table><thead><tr><th style="text-align:center">命令选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">-d</td><td style="text-align:left">添加包含info格式帮助文档的目录</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:left">指定要读取的info格式的帮助文档</td></tr><tr><td style="text-align:center">-n</td><td style="text-align:left">指定首先访问的info帮助文件的节点</td></tr><tr><td style="text-align:center">-o</td><td style="text-align:left">输出被选择的节点内容到指定文件</td></tr></tbody></table><h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><pre><code>[root@centos etc]# info cpFile: coreutils.info,  Node: cp invocation,  Next: dd invocation,  Up: Basic operations11.1 `cp&#39;: Copy files and directories=====================================`cp&#39; copies files (or, optionally, directories).  The copy iscompletely independent of the original.  You can either copy one file toanother, or copy arbitrarily many files to a destination directory.Synopses:     cp [OPTION]... [-T] SOURCE DEST     cp [OPTION]... SOURCE... DIRECTORY     cp [OPTION]... -t DIRECTORY SOURCE...   * If two file names are given, `cp&#39; copies the first file to the     second.   * If the `--target-directory&#39; (`-t&#39;) option is given, or failing     that if the last file is a directory and the     `--no-target-directory&#39; (`-T&#39;) option is not given, `cp&#39; copies     each SOURCE file to the specified directory, using the SOURCEs&#39;     names.   Generally, files are written just as they are read.  For exceptions,see the `--sparse&#39; option below.省略...</code></pre><h4 id="快捷键"><a href="#快捷键" class="headerlink" title="快捷键"></a>快捷键</h4><p>在info命令执行后处于帮助文档显示状态时，可以使用如下快捷操作</p><table><thead><tr><th style="text-align:center">快捷键</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">?键</td><td style="text-align:left">它就会显示info的常用快捷键。</td></tr><tr><td style="text-align:center">N键</td><td style="text-align:left">显示（相对于本节点的）下一节点的文档内容。</td></tr><tr><td style="text-align:center">P键</td><td style="text-align:left">显示（相对于本节点的）前一节点的文档内容。</td></tr><tr><td style="text-align:center">U键</td><td style="text-align:left">进入当前命令所在的主题。</td></tr><tr><td style="text-align:center">M键</td><td style="text-align:left">敲M键后输入命令的名称就可以查看该命令的帮助文档了。</td></tr><tr><td style="text-align:center">G键</td><td style="text-align:left">敲G键后输入主题名称，进入该主题。</td></tr><tr><td style="text-align:center">L键</td><td style="text-align:left">回到上一个访问的页面。</td></tr><tr><td style="text-align:center">SPACE键</td><td style="text-align:left">向前滚动一页。</td></tr><tr><td style="text-align:center">BACKUP或DEL键</td><td style="text-align:left">向后滚动一页。</td></tr><tr><td style="text-align:center">Q</td><td style="text-align:left">退出info。</td></tr></tbody></table><h3 id="man"><a href="#man" class="headerlink" title="man"></a>man</h3><p>man命令是Linux下的帮助指令，通过man指令可以查看Linux中的指令帮助、配置文件帮助和编程帮助等信息</p><h4 id="用法-2"><a href="#用法-2" class="headerlink" title="用法"></a>用法</h4><pre><code>man [选项] [参数]</code></pre><h4 id="选项列举-1"><a href="#选项列举-1" class="headerlink" title="选项列举"></a>选项列举</h4><table><thead><tr><th style="text-align:center">命令选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">-a</td><td style="text-align:left">在所有的man帮助手册中搜索；</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:left">等价于whatis指令，显示给定关键字的简短描述信息；</td></tr><tr><td style="text-align:center">-P</td><td style="text-align:left">指定内容时使用分页程序；</td></tr><tr><td style="text-align:center">-M</td><td style="text-align:left">指定man手册搜索的路径。</td></tr></tbody></table><h4 id="使用-2"><a href="#使用-2" class="headerlink" title="使用"></a>使用</h4><pre><code class="shell">[root@centos etc]# man rmRM(1)                            User Commands                           RM(1)NAME       rm - remove files or directoriesSYNOPSIS       rm [OPTION]... FILE...DESCRIPTION       This manual page documents the GNU version of rm.  rm removes each specified file.  By default, it does not remove directories.....省略以下输出...</code></pre><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>which命令用于查找并显示给定命令的绝对路径，环境变量PATH中保存了查找命令时需要遍历的目录。which指令会在环境变量$PATH设置的目录里查找符合条件的文件。也就是说，使用which命令，就可以看到某个系统命令是否存在，以及执行的到底是哪一个位置的命令。</p><h4 id="用法-3"><a href="#用法-3" class="headerlink" title="用法"></a>用法</h4><pre><code>which [选项] [参数]</code></pre><h4 id="选项列举-2"><a href="#选项列举-2" class="headerlink" title="选项列举"></a>选项列举</h4><table><thead><tr><th style="text-align:center">命令选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">-n&lt;文件名长度&gt;</td><td style="text-align:left">制定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名；</td></tr><tr><td style="text-align:center">-p&lt;文件名长度&gt;</td><td style="text-align:left">与-n参数相同，但此处的&lt;文件名长度&gt;包含了文件的路径；</td></tr><tr><td style="text-align:center">-w</td><td style="text-align:left">指定输出时栏位的宽度；</td></tr><tr><td style="text-align:center">-V</td><td style="text-align:left">显示版本信息。</td></tr></tbody></table><h4 id="使用-3"><a href="#使用-3" class="headerlink" title="使用"></a>使用</h4><pre><code>[root@centos etc]# which -V chownGNU which v2.19, Copyright (C) 1999 - 2008 Carlo Wood.GNU which comes with ABSOLUTELY NO WARRANTY;This program is free software; your freedom to use, changeand distribute this program is protected by the GPL.[root@centos etc]# which adduser/usr/sbin/adduser[root@centos etc]# which pwd/bin/pwd</code></pre><h3 id="whereis"><a href="#whereis" class="headerlink" title="whereis"></a>whereis</h3><p>whereis命令用来定位指令的二进制程序、源代码文件和man手册页等相关文件的路径。whereis命令只能用于程序名的搜索，而且只搜索二进制文件（参数-b）、man说明文件（参数-m）和源代码文件（参数-s）。如果省略参数，则返回所有信息。</p><blockquote><p>和find相比，whereis查找的速度非常快，这是因为linux系统会将 系统内的所有文件都记录在一个数据库文件中，当使用whereis和下面即将介绍的locate时，会从数据库中查找数据，而不是像find命令那样，通 过遍历硬盘来查找，效率自然会很高。 但是该数据库文件并不是实时更新，默认情况下时一星期更新一次，因此，我们在用whereis和locate 查找文件时，有时会找到已经被删除的数据，或者刚刚建立文件，却无法查找到，原因就是因为数据库文件没有被更新。</p></blockquote><h4 id="用法-4"><a href="#用法-4" class="headerlink" title="用法"></a>用法</h4><pre><code>whereis [选项] [参数]</code></pre><h4 id="选项列举-3"><a href="#选项列举-3" class="headerlink" title="选项列举"></a>选项列举</h4><table><thead><tr><th style="text-align:center">命令选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:center">-b</td><td style="text-align:left">只查找二进制文件；</td></tr><tr><td style="text-align:center">-B&lt;目录&gt;</td><td style="text-align:left">只在设置的目录下查找二进制文件；</td></tr><tr><td style="text-align:center">-f</td><td style="text-align:left">不显示文件名前的路径名称；</td></tr><tr><td style="text-align:center">-m</td><td style="text-align:left">只查找说明文件；</td></tr><tr><td style="text-align:center">-M&lt;目录&gt;</td><td style="text-align:left">只在设置的目录下查找说明文件；</td></tr><tr><td style="text-align:center">-s</td><td style="text-align:left">只查找原始代码文件；</td></tr><tr><td style="text-align:center">-S&lt;目录&gt;只在设置的目录下查找原始代码文件；</td></tr><tr><td style="text-align:center">-u</td><td style="text-align:left">查找不包含指定类型的文件。</td></tr></tbody></table><h4 id="使用-4"><a href="#使用-4" class="headerlink" title="使用"></a>使用</h4><pre><code>[root@centos etc]# which pwd/bin/pwd[root@centos etc]# whereis pwdpwd: /bin/pwd /usr/include/pwd.h /usr/share/man/mann/pwd.n.gz /usr/share/man/man1/pwd.1.gz[root@centos etc]# whereis -b  pwdpwd: /bin/pwd /usr/include/pwd.h[root@centos etc]# whereis -s  pwdpwd:</code></pre><h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ol><li>linux命令手册大全：<a href="http://man.linuxde.net/" title="linux命令手册大全" target="_blank" rel="external">http://man.linuxde.net/</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h3&gt;&lt;p&gt;接触和学习过linux的同学相比都知道linux命令的繁多和复杂，无论是linux初学者还是老司机，也不可能把所有linux的命令都记住，好在linux有一一些强大的帮助命令，让我们不用担心不熟悉或者暂时遗忘的命令的情况，下面我们来看怎么去正确的使用这些命令&lt;br&gt;
    
    </summary>
    
      <category term="linux" scheme="http://www.jumpbyte.cn/categories/linux/"/>
    
    
      <category term="linux" scheme="http://www.jumpbyte.cn/tags/linux/"/>
    
      <category term="linux命令" scheme="http://www.jumpbyte.cn/tags/linux%E5%91%BD%E4%BB%A4/"/>
    
  </entry>
  
  <entry>
    <title>gradle日常使用之Java插件</title>
    <link href="http://www.jumpbyte.cn/2016/07/17/gradle-usage/"/>
    <id>http://www.jumpbyte.cn/2016/07/17/gradle-usage/</id>
    <published>2016-07-17T00:34:58.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>Java 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。</p><h3 id="如何引入"><a href="#如何引入" class="headerlink" title="如何引入"></a>如何引入</h3><p>要使用 Java 插件，请在构建脚本(build.gradle)中加入：</p><pre><code class="groovy">apply plugin: &#39;java&#39;</code></pre><a id="more"></a><h3 id="Java项目默认布局"><a href="#Java项目默认布局" class="headerlink" title="Java项目默认布局"></a>Java项目默认布局</h3><table><thead><tr><th style="text-align:left">目录</th><th style="text-align:left">含义</th></tr></thead><tbody><tr><td style="text-align:left">src/main/java</td><td style="text-align:left">产品的Java源代码</td></tr><tr><td style="text-align:left">src/main/resources</td><td style="text-align:left">产品的资源</td></tr><tr><td style="text-align:left">src/test/java</td><td style="text-align:left">Java 测试源代码</td></tr><tr><td style="text-align:left">src/test/resources</td><td style="text-align:left">测试资源</td></tr><tr><td style="text-align:left">src/sourceSet/java</td><td style="text-align:left">给定的源集的Java源代码</td></tr><tr><td style="text-align:left">src/sourceSet/resources</td><td style="text-align:left">给定的源集的资源</td></tr></tbody></table><h3 id="自带任务列举"><a href="#自带任务列举" class="headerlink" title="自带任务列举"></a>自带任务列举</h3><table><thead><tr><th style="text-align:left">任务名称</th><th style="text-align:left">依赖于</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">compileJava</td><td style="text-align:left">产生编译类路径中的所有任务。这包括了用于编译配置中包含的项目依赖关系的jar任务。</td><td style="text-align:left">JavaCompile</td><td style="text-align:left">使用 javac 编译产品中的 Java 源文件。</td></tr><tr><td style="text-align:left">processResources</td><td style="text-align:left">-</td><td style="text-align:left">Copy</td><td style="text-align:left">把生产资源文件拷贝到生产的类目录中。</td></tr><tr><td style="text-align:left">classes</td><td style="text-align:left">compileJava和processResources。一些插件添加了额外的编译任务</td><td style="text-align:left">Task</td><td style="text-align:left">组装生产的类目录。</td></tr><tr><td style="text-align:left">compileTestJava</td><td style="text-align:left">compile，再加上所有能产生测试编译类路径的任务。</td><td style="text-align:left">JavaCompile</td><td style="text-align:left">使用 javac 编译 Java 的测试源文件。</td></tr><tr><td style="text-align:left">processTestResources</td><td style="text-align:left">-</td><td style="text-align:left">Copy</td><td style="text-align:left">把测试的资源文件拷贝到测试的类目录中。</td></tr><tr><td style="text-align:left">testClasses</td><td style="text-align:left">compileTestJava和processTestResources。一些插件添加了额外的测试编译任务。    Task</td><td style="text-align:left">组装测试的类目录。</td></tr><tr><td style="text-align:left">jar</td><td style="text-align:left">compile</td><td style="text-align:left">Jar</td><td style="text-align:left">组装 JAR 文件</td></tr><tr><td style="text-align:left">javadoc</td><td style="text-align:left">compile</td><td style="text-align:left">Javadoc</td><td style="text-align:left">使用 Javadoc 生成生产的 Java 源代码的API文档</td></tr><tr><td style="text-align:left">test</td><td style="text-align:left">compile， compileTest，再加上所有产生测试运行时类路径的任务。</td><td style="text-align:left">Test</td><td style="text-align:left">使用 JUnit 或 TestNG运行单元测试。</td></tr><tr><td style="text-align:left">uploadArchives</td><td style="text-align:left">使用archives的配置生成构件的任务，包括jar。</td><td style="text-align:left">Upload</td><td style="text-align:left">使用archives配置上传包括 JAR 文件的构件。</td></tr><tr><td style="text-align:left">clean</td><td style="text-align:left">-</td><td style="text-align:left">Delete</td><td style="text-align:left">删除项目的build目录。</td></tr><tr><td style="text-align:left">cleanTaskName</td><td style="text-align:left">-</td><td style="text-align:left">Delete</td><td style="text-align:left">删除由指定的任务所产生的输出文件。例如， cleanJar将删除由jar任务中所创建的 JAR 文件，cleanTest将删除由test任务所创建的测试结果。</td></tr></tbody></table><h3 id="源集概念"><a href="#源集概念" class="headerlink" title="源集概念"></a>源集概念</h3><p>Java 插件引入了一个源集的概念。一个源集只是一组用于编译并一起执行的源文件。这些源文件可能包括 Java 源代码文件和资源文件。其他有一些插件添加了在源集里包含 Groovy 和 Scala 的源代码文件的能力。一个源集有一个相关联的编译类路径和运行时类路径。</p><p>源集的一个用途是，把源文件进行逻辑上的分组，以描述它们的目的。例如，你可能会使用一个源集来定义一个集成测试套件，或者你可能会使用单独的源集来定义你的项目的 API 和实现类。</p><p>Java 插件定义了两个标准的源集，分别是main和test。main源集包含你产品的源代码，它们将被编译并组装成一个 JAR 文件。test源集包含你的单元测试的源代码，它们将被编译并使用 JUnit 或 TestNG来执行</p><h3 id="Java-插件-源集任务"><a href="#Java-插件-源集任务" class="headerlink" title="Java 插件-源集任务"></a>Java 插件-源集任务</h3><p>对于每个你添加到该项目中的源集，Java 插件将添加以下的编译任务：</p><table><thead><tr><th style="text-align:left">任务名称</th><th style="text-align:left">依赖于</th><th style="text-align:left">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">compileSourceSetJava</td><td style="text-align:left">所有产生源集编译类路径的任务。</td><td style="text-align:left">JavaCompile</td><td style="text-align:left">使用 javac 编译给定的源集中的 Java 源文件。</td></tr><tr><td style="text-align:left">processSourceSetResources</td><td style="text-align:left">-</td><td style="text-align:left">Copy</td><td style="text-align:left">把给定的源集的资源文件拷贝到类目录中。</td></tr><tr><td style="text-align:left">sourceSetClasses</td><td style="text-align:left">compileSourceSetJava 和 processSourceSetResources。某些插件还为源集添加了额外的编译任务。</td><td style="text-align:left">Task</td><td style="text-align:left">组装给定源集的类目录。</td></tr></tbody></table><h3 id="Java-插件-生命周期任务"><a href="#Java-插件-生命周期任务" class="headerlink" title="Java 插件-生命周期任务"></a>Java 插件-生命周期任务</h3><p>Java 插件还增加了大量的任务构成该项目的生命周期：</p><table><thead><tr><th style="text-align:left">任务名称</th><th style="text-align:left">依赖于</th><th style="text-align:center">类型</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">assemble</td><td style="text-align:left">项目中的所有归档项目，包括jar任务。某些插件还向项目添加额外的归档任务。</td><td style="text-align:center">Task</td><td style="text-align:left">组装项目中所有的归类文件。</td></tr><tr><td style="text-align:left">check</td><td style="text-align:left">项目中的所有核查项目，包括test任务。某些插件还向项目添加额外的核查任务。</td><td style="text-align:center">Task</td><td style="text-align:left">执行项目中所有的核查任务。</td></tr><tr><td style="text-align:left">build</td><td style="text-align:left">check 和 assemble</td><td style="text-align:center">Task</td><td style="text-align:left">执行项目的完事构建。</td></tr><tr><td style="text-align:left">buildNeeded</td><td style="text-align:left">build任务，以及在testRuntime配置的所有项目库依赖项的build任务。</td><td style="text-align:center">Task</td><td style="text-align:left">执行项目本身及它所依赖的其他所有项目的完整构建。</td></tr><tr><td style="text-align:left">buildDependents</td><td style="text-align:left">build任务，以及在testRuntime配置中对此项目有库依赖的所有项目的build任务。</td><td style="text-align:center">Task</td><td style="text-align:left">执行项目本身及依赖它的其他所有项目的完整构建。</td></tr><tr><td style="text-align:left">buildConfigurationName</td><td style="text-align:left">使用配置ConfigurationName生成构件的任务。</td><td style="text-align:center">Task</td><td style="text-align:left">组装指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。</td></tr><tr><td style="text-align:left">uploadConfigurationName</td><td style="text-align:left">使用配置ConfigurationName上传构件的任务。</td><td style="text-align:center">Upload</td><td style="text-align:left">组装并上传指定配置的构件。该任务由Base插件添加，并由Java插件隐式实现。</td></tr></tbody></table><h3 id="Java插件-任务依赖关系图"><a href="#Java插件-任务依赖关系图" class="headerlink" title="Java插件-任务依赖关系图"></a>Java插件-任务依赖关系图</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-7-17/48492582.jpg" alt="Java插件-任务依赖关系图"></p><h3 id="Java插件-​​-依赖配置"><a href="#Java插件-​​-依赖配置" class="headerlink" title="Java插件 ​​- 依赖配置"></a>Java插件 ​​- 依赖配置</h3><p>Java插件向项目添加了许多依赖配置，如下图所示。它对一些任务指定了这些配置，如compileJava和test。</p><table><thead><tr><th>名称</th><th>继承自</th><th>在哪些任务中使用</th><th>意义</th></tr></thead><tbody><tr><td>compile</td><td>-</td><td>compileJava</td><td>编译时依赖</td></tr><tr><td>runtime</td><td>compile</td><td>-</td><td>运行时依赖</td></tr><tr><td>testCompile</td><td>compile</td><td>compileTestJava</td><td>用于编译测试的其他依赖</td></tr><tr><td>testRuntime</td><td>runtime, testCompile</td><td>test</td><td>只用于运行测试的其他依赖</td></tr><tr><td>archives</td><td>-</td><td>uploadArchives</td><td>由本项目生产的构件（如jar包）。</td></tr><tr><td>default</td><td>runtime</td><td>-</td><td>本项目上的默认项目依赖配置。包含本项目运行时所需要的构件和依赖。</td></tr></tbody></table><p>Java插件 ​​- 依赖配置 对于每个你添加到项目中的源集，Java插件都会添加以下的依赖配置：</p><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-7-17/64820034.jpg" alt="默认添加的依赖配置"></p><h3 id="Java插件的常规属性"><a href="#Java插件的常规属性" class="headerlink" title="Java插件的常规属性"></a>Java插件的常规属性</h3><p>Java插件向项目添加了许多常规属性，如下表格所示。您可以在构建脚本中使用这些属性，就像它们是project对象的属性一样</p><table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:left">类型</th><th style="text-align:center">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">reportsDirName</td><td style="text-align:left">String</td><td style="text-align:center">reports</td><td style="text-align:left">相对于build目录的目录名称，报告将生成到此目录。</td></tr><tr><td style="text-align:left">reportsDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">buildDir/reportsDirName</td><td style="text-align:left">报告将生成到此目录。</td></tr><tr><td style="text-align:left">testResultsDirName</td><td style="text-align:left">String</td><td style="text-align:center">test-results</td><td style="text-align:left">相对于build目录的目录名称，测试报告的.xml文件将生成到此目录。</td></tr><tr><td style="text-align:left">testResultsDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">buildDir/testResultsDirName</td><td style="text-align:left">测试报告的.xml文件将生成到此目录。</td></tr><tr><td style="text-align:left">testReportDirName</td><td style="text-align:left">String</td><td style="text-align:center">tests</td><td style="text-align:left">相对于build目录的目录名称，测试报告将生成到此目录。</td></tr><tr><td style="text-align:left">testReportDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">reportsDir/testReportDirName</td><td style="text-align:left">测试报告生成到此目录。</td></tr><tr><td style="text-align:left">libsDirName</td><td style="text-align:left">String</td><td style="text-align:center">libs</td><td style="text-align:left">相对于build目录的目录名称，类库将生成到此目录中。</td></tr><tr><td style="text-align:left">libsDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">buildDir/libsDirName</td><td style="text-align:left">类库将生成到此目录中。</td></tr><tr><td style="text-align:left">distsDirName</td><td style="text-align:left">String</td><td style="text-align:center">distributions</td><td style="text-align:left">相对于build目录的目录名称，发布的文件将生成到此目录中。</td></tr><tr><td style="text-align:left">distsDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">buildDir/distsDirName</td><td style="text-align:left">要发布的文件将生成到此目录。</td></tr><tr><td style="text-align:left">docsDirName</td><td style="text-align:left">String</td><td style="text-align:center">docs</td><td style="text-align:left">相对于build目录的目录名称，文档将生成到此目录。</td></tr><tr><td style="text-align:left">docsDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">buildDir/docsDirName</td><td style="text-align:left">要生成文档的目录。</td></tr><tr><td style="text-align:left">dependencyCacheDirName</td><td style="text-align:left">String</td><td style="text-align:center">dependency-cache</td><td style="text-align:left">相对于build目录的目录名称，该目录用于缓存源代码的依赖信息。</td></tr><tr><td style="text-align:left">dependencyCacheDir</td><td style="text-align:left">File (read-only)</td><td style="text-align:center">buildDir/dependencyCacheDirName</td><td style="text-align:left">该目录用于缓存源代码的依赖信息。</td></tr><tr><td style="text-align:left">sourceSets</td><td style="text-align:left">SourceSetContainer (read-only)</td><td style="text-align:center">非空</td><td style="text-align:left">包含项目的源集。</td></tr><tr><td style="text-align:left">sourceCompatibility</td><td style="text-align:left">JavaVersion.</td><td style="text-align:center">可以使用字符串或数字来设置，例如”1.5”或1.5。</td><td style="text-align:left">当前JVM所使用的值 当编译Java源代码时所使用的Java版本兼容性。</td></tr><tr><td style="text-align:left">targetCompatibility</td><td style="text-align:left">JavaVersion.</td><td style="text-align:center">可以使用字符串或数字来设置，例如”1.5”或1.5。</td><td style="text-align:left">sourceCompatibility 要生成的类的 Java 版本。</td></tr><tr><td style="text-align:left">archivesBaseName</td><td style="text-align:left">String</td><td style="text-align:center">projectName</td><td style="text-align:left">像JAR或ZIP文件这样的构件的basename</td></tr><tr><td style="text-align:left">manifest</td><td style="text-align:left">Manifest</td><td style="text-align:center">一个空的清单</td><td style="text-align:left">要包括的所有 JAR 文件的清单。</td></tr></tbody></table><h3 id="使用源集"><a href="#使用源集" class="headerlink" title="使用源集"></a>使用源集</h3><p>你可以使用sourceSets属性访问项目的源集。这是项目的源集的容器，它的类型是 SourceSetContainer。除此之后，还有一个sourceSets{}的脚本块，可以传入一个闭包来配置源集容器。源集容器的使用方式几乎与其他容器一样，例如tasks。</p><p>示例代码：访问源集的属性</p><pre><code class="gradle">// Various ways to access the main source setprintln sourceSets.main.output.classesDirprintln sourceSets[&#39;main&#39;].output.classesDirsourceSets {    println main.output.classesDir}sourceSets {    main {        println output.classesDir    }}// Iterate over the source setssourceSets.all {    println name}</code></pre><p>示例代码：配置源集的源代码目录</p><p>build.gradle文件</p><pre><code class="gradle">sourceSets {    main {        java {            srcDir &#39;src/java&#39;        }        resources {            srcDir &#39;src/resources&#39;        }    }}</code></pre><h4 id="源集属性列举"><a href="#源集属性列举" class="headerlink" title="源集属性列举"></a>源集属性列举</h4><p>下表列出了一些重要的源集属性。我们可以在SourceSet的 API 文档中查看更多的详细信息。</p><table><thead><tr><th style="text-align:left">属性名称</th><th style="text-align:center">类型</th><th style="text-align:center">默认值</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:left">name</td><td style="text-align:center">String (read-only)</td><td style="text-align:center">非空</td><td style="text-align:left">用来确定一个源集的源集名称。</td></tr><tr><td style="text-align:left">output</td><td style="text-align:center">SourceSetOutput (read-only)</td><td style="text-align:center">非空</td><td style="text-align:left">源集的输出文件，包含它编译过的类和资源。</td></tr><tr><td style="text-align:left">output.classesDir</td><td style="text-align:center">File</td><td style="text-align:center"><em>buildDir/classes/name</em></td><td style="text-align:left">要生成的该源集的类的目录。</td></tr><tr><td style="text-align:left">output.resourcesDir</td><td style="text-align:center">File</td><td style="text-align:center"><em>buildDir/resources/name</em></td><td style="text-align:left">要生成的该源集的资源的目录。</td></tr><tr><td style="text-align:left">compileClasspath</td><td style="text-align:center">FileCollection</td><td style="text-align:center">compileSourceSet 配置</td><td style="text-align:left">该类路径在编译该源集的源文件时使用。</td></tr><tr><td style="text-align:left">runtimeClasspath</td><td style="text-align:center">FileCollection</td><td style="text-align:center">output + runtimeSourceSet 配置</td><td style="text-align:left">该类路径在执行该源集的类时使用。</td></tr><tr><td style="text-align:left">java</td><td style="text-align:center">SourceDirectorySet (read-only)</td><td style="text-align:center">非空</td><td style="text-align:left">该源集的Java源文件。仅包含Java源文件目录里的.java文件，并排除其他所有文件。</td></tr><tr><td style="text-align:left">java.srcDirs</td><td style="text-align:center">Set<file> 可指定一组输入文件来设置</file></td><td style="text-align:center">[<em>projectDir/src/name/java</em>]</td><td style="text-align:left">该源目录包含了此源集的所有Java源文件。</td></tr><tr><td style="text-align:left">resources</td><td style="text-align:center">SourceDirectorySet (read-only)</td><td style="text-align:center">非空</td><td style="text-align:left">此源集的资源文件。仅包含资源文件，并且排除在资源源目录中找到的所有 .java文件。其他插件，如Groovy 插件，会从该集合中排除其他类型的文件。</td></tr><tr><td style="text-align:left">resources.srcDirs</td><td style="text-align:center">Set<file> 指定一组输入文件来设置。</file></td><td style="text-align:center">[<em>projectDir/src/name/resources</em>]</td><td style="text-align:left">该源目录包含了此源集的资源文件。</td></tr><tr><td style="text-align:left">allJava</td><td style="text-align:center">SourceDirectorySet (read-only)</td><td style="text-align:center">java</td><td style="text-align:left">该源集的所有.java 文件。有些插件，如Groovy 插件，会从该集合中增加其他的Java源文件。</td></tr><tr><td style="text-align:left">allSource</td><td style="text-align:center">SourceDirectorySet (read-only)</td><td style="text-align:center">resources + java</td><td style="text-align:left">该源集的所有源文件。包含所有的资源文件和Java源文件。有些插件，如Groovy 插件，会从该集合中增加其他的源文件。</td></tr></tbody></table><h3 id="多项目构建"><a href="#多项目构建" class="headerlink" title="多项目构建"></a>多项目构建</h3><h3 id="创建多项目总结"><a href="#创建多项目总结" class="headerlink" title="创建多项目总结"></a>创建多项目总结</h3><ol><li><p>一个多项目构建必须在根项目的根目录下包含settings.gradle文件，因为它指明了那些包含在多项目构建中的项目。</p></li><li><p>如果需要在多项目构建的所有项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用allprojects)</p></li><li><p>如果需要在根项目的子项目中加入公用的配置或行为，我们可以将这项配置加入到根项目的build.gradle文件中(使用subprojects)</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;Java 插件向一个项目添加了 Java 编译、 测试和 bundling 的能力。它是很多其他 Gradle 插件的基础服务。&lt;/p&gt;
&lt;h3 id=&quot;如何引入&quot;&gt;&lt;a href=&quot;#如何引入&quot; class=&quot;headerlink&quot; title=&quot;如何引入&quot;&gt;&lt;/a&gt;如何引入&lt;/h3&gt;&lt;p&gt;要使用 Java 插件，请在构建脚本(build.gradle)中加入：&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;groovy&quot;&gt;apply plugin: &amp;#39;java&amp;#39;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="Java" scheme="http://www.jumpbyte.cn/categories/Java/"/>
    
    
      <category term="gradle" scheme="http://www.jumpbyte.cn/tags/gradle/"/>
    
      <category term="构建工具" scheme="http://www.jumpbyte.cn/tags/%E6%9E%84%E5%BB%BA%E5%B7%A5%E5%85%B7/"/>
    
  </entry>
  
  <entry>
    <title>为hexo博客加入prettify高亮插件</title>
    <link href="http://www.jumpbyte.cn/2016/07/02/use-and-install-prettify/"/>
    <id>http://www.jumpbyte.cn/2016/07/02/use-and-install-prettify/</id>
    <published>2016-07-02T21:14:37.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<p>使用hexo的默认高亮插件总感觉支持的太少，代码高亮显示的不够细，下面我们来看下怎么把它替换为prettify高亮插件</p><h2 id="第一步：禁用默认高亮插件"><a href="#第一步：禁用默认高亮插件" class="headerlink" title="第一步：禁用默认高亮插件"></a>第一步：禁用默认高亮插件</h2><p>在hexo博客_config.yml中将highlight插件禁用</p><pre><code>highlight:  enable: false  line_number: false  auto_detect: false  tab_replace:</code></pre><a id="more"></a><h2 id="第二步：引用prettify插件"><a href="#第二步：引用prettify插件" class="headerlink" title="第二步：引用prettify插件"></a>第二步：引用prettify插件</h2><h3 id="下载插件"><a href="#下载插件" class="headerlink" title="下载插件"></a><strong>下载插件</strong></h3><p>从github下载<a href="https://github.com/google/code-prettify" target="_blank" rel="external">prettify</a>源码，解压后将src目录重命名(如prettify)，然后拷贝至你的hexo博客的source目录，建议在博客source目录单独建立一个插件目录(plugins)存放，以后所有的插件都放置到此目录，这里我就是拷贝到source/plugins目录下,如图<strong>（注：必须放在source目录下面，否则生成静态文章的时候无法输出到public目录）</strong><br><img src="http://ww2.sinaimg.cn/large/7462786bgw1f5h1gmp2m7j20k709bmzm.jpg" alt=""></p><p>接着我们还要对hexo的_config.yml做如下配置</p><pre><code class="yml">skip_render:    - &quot;plugins/**&quot;</code></pre><p>这个配置就是要告诉hexo对plugins目录下的所有文件跳过解析渲染，因为测试时发现如果不配置，加载prettify的相关js会报脚本错误，猜测hexo渲染造成的编码问题</p><h3 id="引用插件"><a href="#引用插件" class="headerlink" title="引用插件"></a><strong>引用插件</strong></h3><p>在yilia的主题下面找到<code>yilia\layout\_partial\head.ejs</code>和<code>yilia\layout\_partial\after-footer.ejs</code>两个文件，分别引入样式和脚本文件（如果你用的是其他主题，可参照对应）</p><p>在head.ejs中引入样式</p><pre><code class="js">.....省略代码.......&lt;!--prettify代码高亮主题css引入--&gt;&lt;link href=&quot;/plugins/prettify/prettify.css&quot; rel=&quot;stylesheet&quot;&gt;.....省略代码.......</code></pre><p>在after-footer.ejs中引入脚本</p><pre><code class="js">.....省略代码.......&lt;!--prettify代码高亮脚本引入--&gt;&lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(window).load(function(){$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint();})&lt;/script&gt;.....省略代码.......</code></pre><p><strong>注意：脚本文件引入注意一定要在jquery脚本之后</strong></p><p><strong>启动生成浏览</strong></p><p>此时我们用<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo server</code> 发布浏览，结果代码高亮怪怪的，如图:</p><p><img src="http://ww4.sinaimg.cn/large/7462786bgw1f5gnoo6byij210x0g5wi3.jpg" alt=""></p><p>此时F12我们定位此块代码样式发现，刚第一步禁用的highlight高亮插件的样式还是会加载</p><p><img src="http://ww2.sinaimg.cn/large/7462786bgw1f5gnphrzndj21es09kwj8.jpg" alt=""></p><h2 id="第三步：对yilia主题调整修改"><a href="#第三步：对yilia主题调整修改" class="headerlink" title="第三步：对yilia主题调整修改"></a>第三步：对yilia主题调整修改</h2><p> 上一步高亮结果显示有问题，于是立马怀疑yilia主题没有对highlight配置项做开关控制，结果发现在<code>themes\yilia\source\css\style.styl</code>文件确实没有做开关设置，而是直接引入<br><img src="http://ww2.sinaimg.cn/large/7462786bgw1f5h231d2yjj20i60ccdhb.jpg" alt=""></p><p>所以，接下来要稍微做下调整</p><ol><li>把上面的红框标记的那一行注释掉</li><li>仔细观察发现还有样式文件的影响，继续找到<code>themes\yilia\source\css\_partial\article.styl</code>文件先备份下，<br>然后将其中搜下所有pre,code 标签关联的样式删除之</li><li><p>最后再在<code>themes\yilia\source\css\style.styl</code>文件中在加入下面几行调整样式</p><pre><code class="ss">/*解决prettyify在yilia主题下面行号显示问题*/pre.prettyprint{ padding-left: 20px;}/*代码自动换行*/pre{   word-break: break-all;   word-wrap: break-word; }</code></pre></li></ol><h3 id="大功告成"><a href="#大功告成" class="headerlink" title="大功告成"></a><strong>大功告成</strong></h3><p>总算不白折腾，重新hexo生成发布浏览，prettify就能正常高亮代码了<br><img src="http://ww2.sinaimg.cn/large/7462786bgw1f5h4twn7n2j210k0mitc3.jpg" alt=""></p><p>但默认主题样式还不够炫(niu)酷(bi),这里给大家提供n套<a href="https://github.com/jmblog/color-themes-for-google-code-prettify/blob/master/dist/themes.zip" target="_blank" rel="external">prettify主题</a>供大家下载,下载后解压，在themes目录下面有多套主题样式，如图：<br><img src="http://ww2.sinaimg.cn/large/7462786bgw1f5i9ibsy1uj20cd0jegp9.jpg" alt=""></p><p>这里面每套主题都对应一个未压缩版和压缩版，而每套主题的效果，可以<a href="https://jmblog.github.io/color-themes-for-google-code-prettify/" target="_blank" rel="external">点击此链接</a>查看，喜欢那套样式，就直接重命名为prettify替换原来的prettify.css应用即可</p><h2 id="继续优化"><a href="#继续优化" class="headerlink" title="继续优化"></a>继续优化</h2><p>根据上述步骤，我们已经将默认高亮插件成功的替换成prettify高亮插件，但有两处不方便的地方</p><ol><li>prettify插件有很多高亮主题样式，如果以后我们想替换其他主题样式，没有提供可配置主题自动替换</li><li>想换回默认高亮插件得手动还原回去，不灵活<br>基于上面的问题考虑，我们来通过加入几个配置项，使其能够做到灵活切换主题和插件</li></ol><h3 id="增加配置项"><a href="#增加配置项" class="headerlink" title="增加配置项"></a>增加配置项</h3><ol><li><p>在hexo博客的根目录找到_config.yml,加入下面配置</p><pre><code> #prettify 插件位置 # enable 启用和不启用 # theme 使用prettify高亮主题名称 prettify:   enable: true   theme: &quot;这里你可以定义上面下载的themes主题包里面样式文件名，不带.css后缀&quot;</code></pre></li><li><p>在你安装的主题根目录下面找到_config.yml,加入下面配置</p><pre><code> #highlight启用和禁用 highlight:   enable: false</code></pre></li><li><p>将你上面下载的prettify主题包解压后拷贝到博客<code>source/plugins/</code>目录，如下：</p><p><img src="http://ww2.sinaimg.cn/large/7462786bgw1f5ia1mb52vj20bm01ka9y.jpg" alt=""></p></li></ol><h3 id="加入主题开关判断"><a href="#加入主题开关判断" class="headerlink" title="加入主题开关判断"></a>加入主题开关判断</h3><ol><li>修改 themes\yilia\source\css_variables.styl 文件，在文件任意位置加入下面这行<pre><code> highlight = hexo-config(&quot;highlight.enable&quot;)</code></pre></li><li>在themes\yilia\source\css\style.styl文件，加入开关判断<pre><code> if highlight{  @import &quot;_partial/highlight&quot; }</code></pre></li><li><p>分别对<code>yilia\layout\_partial\head.ejs</code>和<code>yilia\layout\_partial\after-footer.ejs</code>两个文件做调整</p><p>head.ejs调整如下：</p><pre><code>&lt;% if (config.prettify.enable){ %&gt;  &lt;!--prettify代码高亮主题css引入--&gt;  &lt;link href=&quot;/plugins/prettify/themes/&lt;%= config.prettify.theme %&gt;.css&quot; rel=&quot;stylesheet&quot;&gt;&lt;% } %&gt;</code></pre><p>after-footer.ejs调整如下：</p><pre><code>&lt;!--prettify代码高亮js引入--&gt;&lt;% if (config.prettify.enable){ %&gt;&lt;script src=&quot;/plugins/prettify/prettify.js&quot;&gt;&lt;/script&gt;&lt;script type=&quot;text/javascript&quot;&gt;$(window).load(function(){$(&#39;pre&#39;).addClass(&#39;prettyprint linenums&#39;).attr(&#39;style&#39;, &#39;overflow:auto;&#39;); prettyPrint();})&lt;/script&gt;&lt;%}%&gt;</code></pre><p>这里引用prettify的样式文件统一定位到/plugins/prettify/themes/下面，所以如果你用默认的prettify.css样式<br>只要要把默认样式也拷贝到/plugins/prettify/themes/目录下面即可</p></li></ol><p>通过以上的配置，我们就可以灵活的切换prettify高亮主题了，并且通过配置可以来回切换高亮插件，只要你想要，就是这么任性！</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;使用hexo的默认高亮插件总感觉支持的太少，代码高亮显示的不够细，下面我们来看下怎么把它替换为prettify高亮插件&lt;/p&gt;
&lt;h2 id=&quot;第一步：禁用默认高亮插件&quot;&gt;&lt;a href=&quot;#第一步：禁用默认高亮插件&quot; class=&quot;headerlink&quot; title=&quot;第一步：禁用默认高亮插件&quot;&gt;&lt;/a&gt;第一步：禁用默认高亮插件&lt;/h2&gt;&lt;p&gt;在hexo博客_config.yml中将highlight插件禁用&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;highlight:
  enable: false
  line_number: false
  auto_detect: false
  tab_replace:
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="折腾记" scheme="http://www.jumpbyte.cn/categories/toss-record/"/>
    
    
      <category term="hexo" scheme="http://www.jumpbyte.cn/tags/hexo/"/>
    
      <category term="prettify" scheme="http://www.jumpbyte.cn/tags/prettify/"/>
    
      <category term="高亮插件" scheme="http://www.jumpbyte.cn/tags/%E9%AB%98%E4%BA%AE%E6%8F%92%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>maven随笔纪录</title>
    <link href="http://www.jumpbyte.cn/2016/06/25/maven_suibi/"/>
    <id>http://www.jumpbyte.cn/2016/06/25/maven_suibi/</id>
    <published>2016-06-25T11:41:41.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="写在前面"><a href="#写在前面" class="headerlink" title="写在前面"></a>写在前面</h1><p>此篇随笔，主要用来纪录博主在日常使用maven过程中的技术知识碎片，里面会包括maven的基本操作和使用过程的问题</p><h1 id="maven知识整理"><a href="#maven知识整理" class="headerlink" title="maven知识整理"></a>maven知识整理</h1><h2 id="向本地仓库添加已有jar包"><a href="#向本地仓库添加已有jar包" class="headerlink" title="向本地仓库添加已有jar包"></a>向本地仓库添加已有jar包</h2><a id="more"></a><p>在maven仓库找不到引用的包，同时还要使用maven来管理，此时我们就需要先去其他官网找到我们自己要用的jar包，然后使用<code>mvn install</code>将其放到我们的本地的maven仓库，之后后在项目pom.xml里面添加此依赖包就可以</p><p>比如引用sqljdbc4.jar包，maven仓库中没有，所以我们先从微软官网下载下来，然后使用下面的命令将期添加到自己的本地仓库中去</p><pre><code>D:\soft\develop\java-jars&gt;mvn install:install-file -Dfile=sqljdbc4.jar -DgroupId=com.microsoft.sqlserver -DartifactId=sqljdbc4 -Dversion=4.0 -Dpackaging=jar[INFO] Scanning for projects...[INFO][INFO] ------------------------------------------------------------------------[INFO] Building Maven Stub Project (No POM) 1[INFO] ------------------------------------------------------------------------[INFO][INFO] --- maven-install-plugin:2.3.1:install-file (default-cli) @ standalone-pom ---[INFO] Installing D:\soft\develop\java-jars\sqljdbc4.jar to C:\Users\yuanjinan\.m2\repository\com\microsoft\sqlserver\sqljdbc4\4.0\sqljdbc4-4.0.jar[INFO] ------------------------------------------------------------------------[INFO] BUILD SUCCESS[INFO] ------------------------------------------------------------------------[INFO] Total time: 0.427s[INFO] Finished at: Sat Jun 25 13:32:34 CST 2016[INFO] Final Memory: 5M/119M[INFO] ------------------------------------------------------------------------</code></pre><p>接着在pom.xml添加依赖</p><pre><code class="xml">&lt;dependency&gt;  &lt;groupId&gt;com.microsoft.sqlserver&lt;/groupId&gt;  &lt;artifactId&gt;sqljdbc4&lt;/artifactId&gt;  &lt;version&gt;4.0&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>此方法也可以方便把我们自己的项目的jar包安装到本地的maven仓库中去</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;写在前面&quot;&gt;&lt;a href=&quot;#写在前面&quot; class=&quot;headerlink&quot; title=&quot;写在前面&quot;&gt;&lt;/a&gt;写在前面&lt;/h1&gt;&lt;p&gt;此篇随笔，主要用来纪录博主在日常使用maven过程中的技术知识碎片，里面会包括maven的基本操作和使用过程的问题&lt;/p&gt;
&lt;h1 id=&quot;maven知识整理&quot;&gt;&lt;a href=&quot;#maven知识整理&quot; class=&quot;headerlink&quot; title=&quot;maven知识整理&quot;&gt;&lt;/a&gt;maven知识整理&lt;/h1&gt;&lt;h2 id=&quot;向本地仓库添加已有jar包&quot;&gt;&lt;a href=&quot;#向本地仓库添加已有jar包&quot; class=&quot;headerlink&quot; title=&quot;向本地仓库添加已有jar包&quot;&gt;&lt;/a&gt;向本地仓库添加已有jar包&lt;/h2&gt;
    
    </summary>
    
      <category term="知识整理" scheme="http://www.jumpbyte.cn/categories/cleared-knowledge/"/>
    
    
      <category term="maven" scheme="http://www.jumpbyte.cn/tags/maven/"/>
    
      <category term="随笔" scheme="http://www.jumpbyte.cn/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="maven使用教程" scheme="http://www.jumpbyte.cn/tags/maven%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>markdown语法手册</title>
    <link href="http://www.jumpbyte.cn/2016/06/19/md-help/"/>
    <id>http://www.jumpbyte.cn/2016/06/19/md-help/</id>
    <published>2016-06-19T09:31:15.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Cmd-Markdown-简明语法手册"><a href="#Cmd-Markdown-简明语法手册" class="headerlink" title="Cmd Markdown 简明语法手册"></a>Cmd Markdown 简明语法手册</h1><p>标签： Cmd-Markdown</p><hr><h3 id="1-斜体和粗体"><a href="#1-斜体和粗体" class="headerlink" title="1. 斜体和粗体"></a>1. 斜体和粗体</h3><p>使用 <em> 和 *</em> 表示斜体和粗体。</p><p>示例：</p><p>这是 <em>斜体</em>，这是 <strong>粗体</strong>。</p><h3 id="2-分级标题"><a href="#2-分级标题" class="headerlink" title="2. 分级标题"></a>2. 分级标题</h3><p>使用 === 表示一级标题，使用 — 表示二级标题。</p><p>示例：</p><a id="more"></a><pre><code>这是一个一级标题============================这是一个二级标题--------------------------------------------------### 这是一个三级标题</code></pre><p>你也可以选择在行首加井号表示不同级别的标题 (H1-H6)，例如：# H1, ## H2, ### H3，#### H4。</p><h3 id="3-外链接"><a href="#3-外链接" class="headerlink" title="3. 外链接"></a>3. 外链接</h3><p>使用 [描述](链接地址) 为文字增加外链接。</p><p>示例：</p><p>这是去往 <a href="http://jumpbyte.cn" target="_blank" rel="external">本人博客</a> 的链接。</p><h3 id="4-无序列表"><a href="#4-无序列表" class="headerlink" title="4. 无序列表"></a>4. 无序列表</h3><p>使用 *，+，- 表示无序列表。</p><p>示例：</p><ul><li>无序列表项 一</li><li>无序列表项 二</li><li>无序列表项 三</li></ul><h3 id="5-有序列表"><a href="#5-有序列表" class="headerlink" title="5. 有序列表"></a>5. 有序列表</h3><p>使用数字和点表示有序列表。</p><p>示例：</p><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><h3 id="6-文字引用"><a href="#6-文字引用" class="headerlink" title="6. 文字引用"></a>6. 文字引用</h3><p>使用 &gt; 表示文字引用。</p><p>示例：</p><blockquote><p>野火烧不尽，春风吹又生。</p></blockquote><h3 id="7-行内代码块"><a href="#7-行内代码块" class="headerlink" title="7. 行内代码块"></a>7. 行内代码块</h3><p>使用 `代码` 表示行内代码块。</p><p>示例：</p><p>让我们聊聊 <code>html</code>。</p><h3 id="8-代码块"><a href="#8-代码块" class="headerlink" title="8.  代码块"></a>8.  代码块</h3><p>使用 四个缩进空格 表示代码块。</p><p>示例：</p><pre><code>这是一个代码块，此行左侧有四个不可见的空格。</code></pre><h3 id="9-插入图像"><a href="#9-插入图像" class="headerlink" title="9.  插入图像"></a>9.  插入图像</h3><p>使用 ![描述](图片链接地址) 插入图像。</p><p>示例：</p><p><img src="http://tva4.sinaimg.cn/crop.154.494.1235.1235.180/7462786bjw8f4rmzsmb6kj216w1psdlj.jpg" alt="我的头像"></p><h1 id="Cmd-Markdown-高阶语法手册"><a href="#Cmd-Markdown-高阶语法手册" class="headerlink" title="Cmd Markdown 高阶语法手册"></a>Cmd Markdown 高阶语法手册</h1><h3 id="1-内容目录"><a href="#1-内容目录" class="headerlink" title="1. 内容目录"></a>1. 内容目录</h3><p>在段落中填写 <code>[TOC]</code> 以显示全文内容的目录结构。</p><p>[TOC]</p><h3 id="2-标签分类"><a href="#2-标签分类" class="headerlink" title="2. 标签分类"></a>2. 标签分类</h3><p>在编辑区任意行的列首位置输入以下代码给文稿标签：</p><p>标签： 数学 英语 Markdown</p><p>或者</p><p>Tags： 数学 英语 Markdown</p><h3 id="3-删除线"><a href="#3-删除线" class="headerlink" title="3. 删除线"></a>3. 删除线</h3><p>使用 ~~ 表示删除线。</p><p><del>这是一段错误的文本。</del></p><h3 id="4-注脚"><a href="#4-注脚" class="headerlink" title="4. 注脚"></a>4. 注脚</h3><p>使用 [^keyword] 表示注脚。</p><p>这是一个注脚[^footnote]的样例。</p><p>这是第二个注脚[^footnote2]的样例。</p><h3 id="5-LaTeX-公式"><a href="#5-LaTeX-公式" class="headerlink" title="5. LaTeX 公式"></a>5. LaTeX 公式</h3><p>$ 表示行内公式：</p><p>质能守恒方程可以用一个很简洁的方程式 $E=mc^2$ 来表达。</p><p>$$ 表示整行公式：</p><p>$$\sum_{i=1}^n a_i=0$$</p><p>$$f(x_1,x_x,\ldots,x_n) = x_1^2 + x_2^2 + \cdots + x_n^2 $$</p><p>$$\sum^{j-1}<em>{k=0}{\widehat{\gamma}</em>{kj} z_k}$$</p><p>访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p><h3 id="6-加强的代码块"><a href="#6-加强的代码块" class="headerlink" title="6. 加强的代码块"></a>6. 加强的代码块</h3><p>支持四十一种编程语言的语法高亮的显示，行号显示。</p><p>非代码示例：</p><pre><code>$ sudo apt-get install vim-gnome</code></pre><p>Python 示例：</p><pre><code class="python">@requires_authorizationdef somefunc(param1=&#39;&#39;, param2=0):    &#39;&#39;&#39;A docstring&#39;&#39;&#39;    if param1 &gt; param2: # interesting        print &#39;Greater&#39;    return (param2 - param1 + 1) or Noneclass SomeClass:    pass&gt;&gt;&gt; message = &#39;&#39;&#39;interpreter... prompt&#39;&#39;&#39;</code></pre><p>JavaScript 示例：</p><pre><code class="javascript">/*** nth element in the fibonacci series.* @param n &gt;= 0* @return the nth element, &gt;= 0.*/function fib(n) {  var a = 1, b = 1;  var tmp;  while (--n &gt;= 0) {    tmp = a;    a += b;    b = tmp;  }  return a;}document.write(fib(10));</code></pre><h3 id="7-流程图"><a href="#7-流程图" class="headerlink" title="7. 流程图"></a>7. 流程图</h3><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><pre><code class="flow">st=&gt;start: Start:&gt;https://www.zybuluo.comio=&gt;inputoutput: verificationop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?sub=&gt;subroutine: Your Subroutinee=&gt;endst-&gt;io-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;sub-&gt;io</code></pre><h4 id="更多语法参考：流程图语法参考"><a href="#更多语法参考：流程图语法参考" class="headerlink" title="更多语法参考：流程图语法参考"></a>更多语法参考：<a href="http://adrai.github.io/flowchart.js/" target="_blank" rel="external">流程图语法参考</a></h4><h3 id="8-序列图"><a href="#8-序列图" class="headerlink" title="8. 序列图"></a>8. 序列图</h3><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例 1"></a>示例 1</h4><pre><code class="seq">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例 2"></a>示例 2</h4><pre><code class="seq">Title: Here is a titleA-&gt;B: Normal lineB--&gt;C: Dashed lineC-&gt;&gt;D: Open arrowD--&gt;&gt;A: Dashed open arrow</code></pre><h4 id="更多语法参考：序列图语法参考"><a href="#更多语法参考：序列图语法参考" class="headerlink" title="更多语法参考：序列图语法参考"></a>更多语法参考：<a href="http://bramp.github.io/js-sequence-diagrams/" target="_blank" rel="external">序列图语法参考</a></h4><h3 id="9-表格支持"><a href="#9-表格支持" class="headerlink" title="9. 表格支持"></a>9. 表格支持</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="10-定义型列表"><a href="#10-定义型列表" class="headerlink" title="10. 定义型列表"></a>10. 定义型列表</h3><p>名词 1<br>:   定义 1（左侧有一个可见的冒号和四个不可见的空格）</p><p>代码块 2<br>:   这是代码块的定义（左侧有一个可见的冒号和四个不可见的空格）</p><pre><code>    代码块（左侧有八个不可见的空格）</code></pre><h3 id="11-Html-标签"><a href="#11-Html-标签" class="headerlink" title="11. Html 标签"></a>11. Html 标签</h3><p>本站支持在 Markdown 语法中嵌套 Html 标签，譬如，你可以用 Html 写一个纵跨两行的表格：</p><pre><code>&lt;table&gt;    &lt;tr&gt;        &lt;th rowspan=&quot;2&quot;&gt;值班人员&lt;/th&gt;        &lt;th&gt;星期一&lt;/th&gt;        &lt;th&gt;星期二&lt;/th&gt;        &lt;th&gt;星期三&lt;/th&gt;    &lt;/tr&gt;    &lt;tr&gt;        &lt;td&gt;李强&lt;/td&gt;        &lt;td&gt;张明&lt;/td&gt;        &lt;td&gt;王平&lt;/td&gt;    &lt;/tr&gt;&lt;/table&gt;</code></pre><table><br>    <tr><br>        <th rowspan="2">值班人员</th><br>        <th>星期一</th><br>        <th>星期二</th><br>        <th>星期三</th><br>    </tr><br>    <tr><br>        <td>李强</td><br>        <td>张明</td><br>        <td>王平</td><br>    </tr><br></table><h3 id="12-内嵌图标"><a href="#12-内嵌图标" class="headerlink" title="12. 内嵌图标"></a>12. 内嵌图标</h3><p>本站的图标系统对外开放，在文档中输入</p><pre><code>&lt;i class=&quot;icon-weibo&quot;&gt;&lt;/i&gt;</code></pre><p>即显示微博的图标： <i class="icon-weibo icon-2x"></i></p><p>替换 上述 <code>i 标签</code> 内的 <code>icon-weibo</code> 以显示不同的图标，例如：</p><pre><code>&lt;i class=&quot;icon-renren&quot;&gt;&lt;/i&gt;</code></pre><p>即显示人人的图标： <i class="icon-renren icon-2x"></i></p><p>更多的图标和玩法可以参看 <a href="http://fortawesome.github.io/Font-Awesome/3.2.1/icons/" target="_blank" rel="external">font-awesome</a> 官方网站。</p><h3 id="13-待办事宜-Todo-列表"><a href="#13-待办事宜-Todo-列表" class="headerlink" title="13. 待办事宜 Todo 列表"></a>13. 待办事宜 Todo 列表</h3><p>使用带有 [ ] 或 [x] （未完成或已完成）项的列表语法撰写一个待办事宜列表，并且支持子列表嵌套以及混用Markdown语法，例如：</p><pre><code>- [ ] **Cmd Markdown 开发**    - [ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率    - [ ] 支持以 PDF 格式导出文稿    - [x] 新增Todo列表功能 [语法参考](https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments)    - [x] 改进 LaTex 功能        - [x] 修复 LaTex 公式渲染问题        - [x] 新增 LaTex 公式编号功能 [语法参考](http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers)- [ ] **七月旅行准备**    - [ ] 准备邮轮上需要携带的物品    - [ ] 浏览日本免税店的物品    - [x] 购买蓝宝石公主号七月一日的船票</code></pre><p>对应显示如下待办事宜 Todo 列表：</p><ul><li>[ ] <strong>Cmd Markdown 开发</strong><ul><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[ ] 支持以 PDF 格式导出文稿</li><li>[x] 新增Todo列表功能 <a href="https://github.com/blog/1375-task-lists-in-gfm-issues-pulls-comments" target="_blank" rel="external">语法参考</a></li><li>[x] 改进 LaTex 功能<ul><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能 <a href="http://docs.mathjax.org/en/latest/tex.html#tex-eq-numbers" target="_blank" rel="external">语法参考</a></li></ul></li></ul></li><li>[ ] <strong>七月旅行准备</strong><ul><li>[ ] 准备邮轮上需要携带的物品</li><li>[ ] 浏览日本免税店的物品</li><li>[x] 购买蓝宝石公主号七月一日的船票</li></ul></li></ul><p>[^footnote]: 这是一个 <em>注脚</em> 的 <strong>文本</strong>。</p><p>[^footnote2]: 这是另一个 <em>注脚</em> 的 <strong>文本</strong>。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Cmd-Markdown-简明语法手册&quot;&gt;&lt;a href=&quot;#Cmd-Markdown-简明语法手册&quot; class=&quot;headerlink&quot; title=&quot;Cmd Markdown 简明语法手册&quot;&gt;&lt;/a&gt;Cmd Markdown 简明语法手册&lt;/h1&gt;&lt;p&gt;标签： Cmd-Markdown&lt;/p&gt;
&lt;hr&gt;
&lt;h3 id=&quot;1-斜体和粗体&quot;&gt;&lt;a href=&quot;#1-斜体和粗体&quot; class=&quot;headerlink&quot; title=&quot;1. 斜体和粗体&quot;&gt;&lt;/a&gt;1. 斜体和粗体&lt;/h3&gt;&lt;p&gt;使用 &lt;em&gt; 和 *&lt;/em&gt; 表示斜体和粗体。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
&lt;p&gt;这是 &lt;em&gt;斜体&lt;/em&gt;，这是 &lt;strong&gt;粗体&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;2-分级标题&quot;&gt;&lt;a href=&quot;#2-分级标题&quot; class=&quot;headerlink&quot; title=&quot;2. 分级标题&quot;&gt;&lt;/a&gt;2. 分级标题&lt;/h3&gt;&lt;p&gt;使用 === 表示一级标题，使用 — 表示二级标题。&lt;/p&gt;
&lt;p&gt;示例：&lt;/p&gt;
    
    </summary>
    
      <category term="markdown" scheme="http://www.jumpbyte.cn/categories/markdown/"/>
    
    
      <category term="markdown" scheme="http://www.jumpbyte.cn/tags/markdown/"/>
    
      <category term="markdown语法" scheme="http://www.jumpbyte.cn/tags/markdown%E8%AF%AD%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>如何使用Cmd Markdown 编写MarkDown文档</title>
    <link href="http://www.jumpbyte.cn/2016/06/19/howto-use-markdownedit/"/>
    <id>http://www.jumpbyte.cn/2016/06/19/howto-use-markdownedit/</id>
    <published>2016-06-19T08:25:26.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎使用-Cmd-Markdown-编辑阅读器"><a href="#欢迎使用-Cmd-Markdown-编辑阅读器" class="headerlink" title="欢迎使用 Cmd Markdown 编辑阅读器"></a>欢迎使用 Cmd Markdown 编辑阅读器</h1><hr><p>我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，<strong>Cmd Markdown</strong> 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：</p><blockquote><ul><li>整理知识，学习笔记</li><li>发布日记，杂文，所见所想</li><li>撰写发布技术文稿（代码支持）</li><li>撰写发布学术论文（LaTeX 公式支持）<a id="more"></a><img src="https://www.zybuluo.com/static/img/logo.png" alt="cmd-markdown-logo"></li></ul></blockquote><p>除了您现在看到的这个 Cmd Markdown 在线版本，您还可以前往以下网址下载：</p><h3 id="Windows-Mac-Linux-全平台客户端"><a href="#Windows-Mac-Linux-全平台客户端" class="headerlink" title="Windows/Mac/Linux 全平台客户端"></a><a href="https://www.zybuluo.com/cmd/" target="_blank" rel="external">Windows/Mac/Linux 全平台客户端</a></h3><blockquote><p>请保留此份 Cmd Markdown 的欢迎稿兼使用说明，如需撰写新稿件，点击顶部工具栏右侧的 <i class="icon-file"></i> <strong>新文稿</strong> 或者使用快捷键 <code>Ctrl+Alt+N</code>。</p></blockquote><hr><h2 id="什么是-Markdown"><a href="#什么是-Markdown" class="headerlink" title="什么是 Markdown"></a>什么是 Markdown</h2><p>Markdown 是一种方便记忆、书写的纯文本标记语言，用户可以使用这些标记符号以最小的输入代价生成极富表现力的文档：譬如您正在阅读的这份文档。它使用简单的符号标记不同的标题，分割不同的段落，<strong>粗体</strong> 或者 <em>斜体</em> 某些文字，更棒的是，它还可以</p><h3 id="1-制作一份待办事宜-Todo-列表"><a href="#1-制作一份待办事宜-Todo-列表" class="headerlink" title="1. 制作一份待办事宜 Todo 列表"></a>1. 制作一份待办事宜 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#13-待办事宜-todo-列表" target="_blank" rel="external">Todo 列表</a></h3><ul><li>[ ] 支持以 PDF 格式导出文稿</li><li>[ ] 改进 Cmd 渲染算法，使用局部渲染技术提高渲染效率</li><li>[x] 新增 Todo 列表功能</li><li>[x] 修复 LaTex 公式渲染问题</li><li>[x] 新增 LaTex 公式编号功能</li></ul><h3 id="2-书写一个质能守恒公式-LaTeX"><a href="#2-书写一个质能守恒公式-LaTeX" class="headerlink" title="2. 书写一个质能守恒公式[^LaTeX]"></a>2. 书写一个质能守恒公式[^LaTeX]</h3><p>$$E=mc^2$$</p><h3 id="3-高亮一段代码-code"><a href="#3-高亮一段代码-code" class="headerlink" title="3. 高亮一段代码[^code]"></a>3. 高亮一段代码[^code]</h3><pre><code class="python">@requires_authorizationclass SomeClass:    passif __name__ == &#39;__main__&#39;:    # A comment    print &#39;hello world&#39;</code></pre><h3 id="4-高效绘制-流程图"><a href="#4-高效绘制-流程图" class="headerlink" title="4. 高效绘制 流程图"></a>4. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#7-流程图" target="_blank" rel="external">流程图</a></h3><pre><code class="flow">st=&gt;start: Startop=&gt;operation: Your Operationcond=&gt;condition: Yes or No?e=&gt;endst-&gt;op-&gt;condcond(yes)-&gt;econd(no)-&gt;op</code></pre><h3 id="5-高效绘制-序列图"><a href="#5-高效绘制-序列图" class="headerlink" title="5. 高效绘制 序列图"></a>5. 高效绘制 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#8-序列图" target="_blank" rel="external">序列图</a></h3><pre><code class="seq">Alice-&gt;Bob: Hello Bob, how are you?Note right of Bob: Bob thinksBob--&gt;Alice: I am good thanks!</code></pre><h3 id="6-绘制表格"><a href="#6-绘制表格" class="headerlink" title="6. 绘制表格"></a>6. 绘制表格</h3><table><thead><tr><th>项目</th><th style="text-align:right">价格</th><th style="text-align:center">数量</th></tr></thead><tbody><tr><td>计算机</td><td style="text-align:right">\$1600</td><td style="text-align:center">5</td></tr><tr><td>手机</td><td style="text-align:right">\$12</td><td style="text-align:center">12</td></tr><tr><td>管线</td><td style="text-align:right">\$1</td><td style="text-align:center">234</td></tr></tbody></table><h3 id="7-更详细语法说明"><a href="#7-更详细语法说明" class="headerlink" title="7. 更详细语法说明"></a>7. 更详细语法说明</h3><p>想要查看更详细的语法说明，可以参考我们准备的 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown" target="_blank" rel="external">Cmd Markdown 简明语法手册</a>，进阶用户可以参考 <a href="https://www.zybuluo.com/mdeditor?url=https://www.zybuluo.com/static/editor/md-help.markdown#cmd-markdown-高阶语法手册" target="_blank" rel="external">Cmd Markdown 高阶语法手册</a> 了解更多高级功能。</p><p>总而言之，不同于其它 <em>所见即所得</em> 的编辑器：你只需使用键盘专注于书写文本内容，就可以生成印刷级的排版格式，省却在键盘和工具栏之间来回切换，调整内容和格式的麻烦。<strong>Markdown 在流畅的书写和印刷级的阅读体验之间找到了平衡。</strong> 目前它已经成为世界上最大的技术分享网站 GitHub 和 技术问答网站 StackOverFlow 的御用书写格式。</p><hr><h2 id="什么是-Cmd-Markdown"><a href="#什么是-Cmd-Markdown" class="headerlink" title="什么是 Cmd Markdown"></a>什么是 Cmd Markdown</h2><p>您可以使用很多工具书写 Markdown，但是 Cmd Markdown 是这个星球上我们已知的、最好的 Markdown 工具——没有之一 ：）因为深信文字的力量，所以我们和你一样，对流畅书写，分享思想和知识，以及阅读体验有极致的追求，我们把对于这些诉求的回应整合在 Cmd Markdown，并且一次，两次，三次，乃至无数次地提升这个工具的体验，最终将它演化成一个 <strong>编辑/发布/阅读</strong> Markdown 的在线平台——您可以在任何地方，任何系统/设备上管理这里的文字。</p><h3 id="1-实时同步预览"><a href="#1-实时同步预览" class="headerlink" title="1. 实时同步预览"></a>1. 实时同步预览</h3><p>我们将 Cmd Markdown 的主界面一分为二，左边为<strong>编辑区</strong>，右边为<strong>预览区</strong>，在编辑区的操作会实时地渲染到预览区方便查看最终的版面效果，并且如果你在其中一个区拖动滚动条，我们有一个巧妙的算法把另一个区的滚动条同步到等价的位置，超酷！</p><h3 id="2-编辑工具栏"><a href="#2-编辑工具栏" class="headerlink" title="2. 编辑工具栏"></a>2. 编辑工具栏</h3><p>也许您还是一个 Markdown 语法的新手，在您完全熟悉它之前，我们在 <strong>编辑区</strong> 的顶部放置了一个如下图所示的工具栏，您可以使用鼠标在工具栏上调整格式，不过我们仍旧鼓励你使用键盘标记格式，提高书写的流畅度。</p><p><img src="https://www.zybuluo.com/static/img/toolbar-editor.png" alt="tool-editor"></p><h3 id="3-编辑模式"><a href="#3-编辑模式" class="headerlink" title="3. 编辑模式"></a>3. 编辑模式</h3><p>完全心无旁骛的方式编辑文字：点击 <strong>编辑工具栏</strong> 最右测的拉伸按钮或者按下 <code>Ctrl + M</code>，将 Cmd Markdown 切换到独立的编辑模式，这是一个极度简洁的写作环境，所有可能会引起分心的元素都已经被挪除，超清爽！</p><h3 id="4-实时的云端文稿"><a href="#4-实时的云端文稿" class="headerlink" title="4. 实时的云端文稿"></a>4. 实时的云端文稿</h3><p>为了保障数据安全，Cmd Markdown 会将您每一次击键的内容保存至云端，同时在 <strong>编辑工具栏</strong> 的最右侧提示 <code>已保存</code> 的字样。无需担心浏览器崩溃，机器掉电或者地震，海啸——在编辑的过程中随时关闭浏览器或者机器，下一次回到 Cmd Markdown 的时候继续写作。</p><h3 id="5-离线模式"><a href="#5-离线模式" class="headerlink" title="5. 离线模式"></a>5. 离线模式</h3><p>在网络环境不稳定的情况下记录文字一样很安全！在您写作的时候，如果电脑突然失去网络连接，Cmd Markdown 会智能切换至离线模式，将您后续键入的文字保存在本地，直到网络恢复再将他们传送至云端，即使在网络恢复前关闭浏览器或者电脑，一样没有问题，等到下次开启 Cmd Markdown 的时候，她会提醒您将离线保存的文字传送至云端。简而言之，我们尽最大的努力保障您文字的安全。</p><h3 id="6-管理工具栏"><a href="#6-管理工具栏" class="headerlink" title="6. 管理工具栏"></a>6. 管理工具栏</h3><p>为了便于管理您的文稿，在 <strong>预览区</strong> 的顶部放置了如下所示的 <strong>管理工具栏</strong>：</p><p><img src="https://www.zybuluo.com/static/img/toolbar-manager.jpg" alt="tool-manager"></p><p>通过管理工具栏可以：</p><p><i class="icon-share"></i> 发布：将当前的文稿生成固定链接，在网络上发布，分享<br><i class="icon-file"></i> 新建：开始撰写一篇新的文稿<br><i class="icon-trash"></i> 删除：删除当前的文稿<br><i class="icon-cloud"></i> 导出：将当前的文稿转化为 Markdown 文本或者 Html 格式，并导出到本地<br><i class="icon-reorder"></i> 列表：所有新增和过往的文稿都可以在这里查看、操作<br><i class="icon-pencil"></i> 模式：切换 普通/Vim/Emacs 编辑模式</p><h3 id="7-阅读工具栏"><a href="#7-阅读工具栏" class="headerlink" title="7. 阅读工具栏"></a>7. 阅读工具栏</h3><p><img src="https://www.zybuluo.com/static/img/toolbar-reader.jpg" alt="tool-manager"></p><p>通过 <strong>预览区</strong> 右上角的 <strong>阅读工具栏</strong>，可以查看当前文稿的目录并增强阅读体验。</p><p>工具栏上的五个图标依次为：</p><p><i class="icon-list"></i> 目录：快速导航当前文稿的目录结构以跳转到感兴趣的段落<br><i class="icon-chevron-sign-left"></i> 视图：互换左边编辑区和右边预览区的位置<br><i class="icon-adjust"></i> 主题：内置了黑白两种模式的主题，试试 <strong>黑色主题</strong>，超炫！<br><i class="icon-desktop"></i> 阅读：心无旁骛的阅读模式提供超一流的阅读体验<br><i class="icon-fullscreen"></i> 全屏：简洁，简洁，再简洁，一个完全沉浸式的写作和阅读环境</p><h3 id="8-阅读模式"><a href="#8-阅读模式" class="headerlink" title="8. 阅读模式"></a>8. 阅读模式</h3><p>在 <strong>阅读工具栏</strong> 点击 <i class="icon-desktop"></i> 或者按下 <code>Ctrl+Alt+M</code> 随即进入独立的阅读模式界面，我们在版面渲染上的每一个细节：字体，字号，行间距，前背景色都倾注了大量的时间，努力提升阅读的体验和品质。</p><h3 id="9-标签、分类和搜索"><a href="#9-标签、分类和搜索" class="headerlink" title="9. 标签、分类和搜索"></a>9. 标签、分类和搜索</h3><p>在编辑区任意行首位置输入以下格式的文字可以标签当前文档：</p><p>标签： 未分类</p><p>标签以后的文稿在【文件列表】（Ctrl+Alt+F）里会按照标签分类，用户可以同时使用键盘或者鼠标浏览查看，或者在【文件列表】的搜索文本框内搜索标题关键字过滤文稿，如下图所示：</p><p><img src="https://www.zybuluo.com/static/img/file-list.png" alt="file-list"></p><h3 id="10-文稿发布和分享"><a href="#10-文稿发布和分享" class="headerlink" title="10. 文稿发布和分享"></a>10. 文稿发布和分享</h3><p>在您使用 Cmd Markdown 记录，创作，整理，阅读文稿的同时，我们不仅希望它是一个有力的工具，更希望您的思想和知识通过这个平台，连同优质的阅读体验，将他们分享给有相同志趣的人，进而鼓励更多的人来到这里记录分享他们的思想和知识，尝试点击 <i class="icon-share"></i> (Ctrl+Alt+P) 发布这份文档给好友吧！</p><hr><p>再一次感谢您花费时间阅读这份欢迎稿，点击 <i class="icon-file"></i> (Ctrl+Alt+N) 开始撰写新的文稿吧！祝您在这里记录、阅读、分享愉快！</p><p>作者 <a href="http://weibo.com/ghosert" target="_blank" rel="external">@ghosert</a><br>2015 年 06月 15日    </p><p>[^LaTeX]: 支持 <strong>LaTeX</strong> 编辑显示支持，例如：$\sum_{i=1}^n a_i=0$， 访问 <a href="http://meta.math.stackexchange.com/questions/5020/mathjax-basic-tutorial-and-quick-reference" target="_blank" rel="external">MathJax</a> 参考更多使用方法。</p><p>[^code]: 代码高亮功能支持包括 Java, Python, JavaScript 在内的，<strong>四十一</strong>种主流编程语言。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;欢迎使用-Cmd-Markdown-编辑阅读器&quot;&gt;&lt;a href=&quot;#欢迎使用-Cmd-Markdown-编辑阅读器&quot; class=&quot;headerlink&quot; title=&quot;欢迎使用 Cmd Markdown 编辑阅读器&quot;&gt;&lt;/a&gt;欢迎使用 Cmd Markdown 编辑阅读器&lt;/h1&gt;&lt;hr&gt;
&lt;p&gt;我们理解您需要更便捷更高效的工具记录思想，整理笔记、知识，并将其中承载的价值传播给他人，&lt;strong&gt;Cmd Markdown&lt;/strong&gt; 是我们给出的答案 —— 我们为记录思想和分享知识提供更专业的工具。 您可以使用 Cmd Markdown：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ul&gt;
&lt;li&gt;整理知识，学习笔记&lt;/li&gt;
&lt;li&gt;发布日记，杂文，所见所想&lt;/li&gt;
&lt;li&gt;撰写发布技术文稿（代码支持）&lt;/li&gt;
&lt;li&gt;撰写发布学术论文（LaTeX 公式支持）
    
    </summary>
    
      <category term="markdown" scheme="http://www.jumpbyte.cn/categories/markdown/"/>
    
    
      <category term="CmdMarkdown" scheme="http://www.jumpbyte.cn/tags/CmdMarkdown/"/>
    
      <category term="markdown" scheme="http://www.jumpbyte.cn/tags/markdown/"/>
    
      <category term="test" scheme="http://www.jumpbyte.cn/tags/test/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate Session中createQuery()和createSQLSquery()方法的区别</title>
    <link href="http://www.jumpbyte.cn/2014/06/04/createquery-vs-createsqlsquery/"/>
    <id>http://www.jumpbyte.cn/2014/06/04/createquery-vs-createsqlsquery/</id>
    <published>2014-06-04T18:37:29.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<p>本文将介绍Hibernate的Session类createQuery, createSQLSquery方法两个区别及如何使用</p><h3 id="createQuery"><a href="#createQuery" class="headerlink" title="createQuery"></a>createQuery</h3><p>可以使用”FROM Student”这样的HQL语句进行查询，其中”Student”是持久化Student类的名称</p><a id="more"></a><p>例如：</p><pre><code class="Java">Session session = factory.openSession();Query query = session.createQuery(&quot;FROM Student where studentId=&quot;+ stuId);Student ss = (Student) query.list().get(0);System.out.println(ss.getName() + &quot;    &quot; + ss.getAge());session.close();</code></pre><h3 id="createSQLQuery"><a href="#createSQLQuery" class="headerlink" title="createSQLQuery"></a>createSQLQuery</h3><p>可以像”select * from student”这样使用原生数据库语法编写查询语句，其中student是一个表的名称</p><p>例如：</p><pre><code class="Java">Session session = factory.openSession();SQLQuery query = session.createSQLQuery(&quot;select * from student where student_id=&quot;+stuId);query.addEntity(Student.class);List list = query.list();for (Object ss : list) {  System.out.println(((Object)ss).getName() + &quot;    &quot; + ((Object)ss).getAge());  session.close();}    session.close();</code></pre><p>query.addEntity(Student.class)这句是指定将数据库查询的数据映射到指定的实体类，如果不指定将会以Object[Object[]]返回行数据</p><h3 id="get"><a href="#get" class="headerlink" title="get()"></a>get()</h3><p>用给定的对象标识返回给定的持久化实体类（Student.hbm.xml为实体类映射文件，实体标识id映射数据库的主键student_id）<br>例如</p><pre><code class="Java">Session session = factory.openSession();Student ss = (Student) session.get(Student.class,student_id);System.out.println(ss.getName() + &quot;    &quot; + ss.getAge());session.close();</code></pre>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;本文将介绍Hibernate的Session类createQuery, createSQLSquery方法两个区别及如何使用&lt;/p&gt;
&lt;h3 id=&quot;createQuery&quot;&gt;&lt;a href=&quot;#createQuery&quot; class=&quot;headerlink&quot; title=&quot;createQuery&quot;&gt;&lt;/a&gt;createQuery&lt;/h3&gt;&lt;p&gt;可以使用”FROM Student”这样的HQL语句进行查询，其中”Student”是持久化Student类的名称&lt;/p&gt;
    
    </summary>
    
      <category term="Hibernate" scheme="http://www.jumpbyte.cn/categories/Hibernate/"/>
    
    
      <category term="hibernate" scheme="http://www.jumpbyte.cn/tags/hibernate/"/>
    
      <category term="java" scheme="http://www.jumpbyte.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>jquery实现页面置顶功能</title>
    <link href="http://www.jumpbyte.cn/2013/11/26/jquery%E5%AE%9E%E7%8E%B0%E9%A1%B5%E9%9D%A2%E7%BD%AE%E9%A1%B6%E5%8A%9F%E8%83%BD/"/>
    <id>http://www.jumpbyte.cn/2013/11/26/jquery实现页面置顶功能/</id>
    <published>2013-11-26T09:14:00.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="实现代码"><a href="#实现代码" class="headerlink" title="实现代码"></a>实现代码</h3><p><br></p><pre><code class="js">&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;br&gt;&lt;script type=&#39;text/javascript&gt;//回到顶部功能function gotoTop(min_height) {    $(&quot;#toTop&quot;).click(//定义返回顶部点击向上滚动的动画        function () {            $(&#39;html,body&#39;).animate({ scrollTop: 0 }, 700);        });    //获取页面的最小高度，无传入值则默认为600像素    min_height ? min_height = min_height : min_height = 600;    //为窗口的scroll事件绑定处理函数    $(window).scroll(function () {        //获取窗口的滚动条的垂直位置        var s = $(window).scrollTop();        //当窗口的滚动条的垂直位置大于页面的最小高度时，让返回顶部元素渐现，否则渐隐        if (s &gt; min_height) {            $(&quot;#totop&quot;).fadeIn(100);        } else {            $(&quot;#toTop&quot;).fadeOut(200);        };    });};&lt;/script&gt;&#39; &lt;/head&gt;    &lt;body&gt;       &lt;div id=&#39;toTop&#39; &gt;&lt;/div&gt;   &lt;/body&gt;&lt;/html&gt;</code></pre><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/p/3442638.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;实现代码&quot;&gt;&lt;a href=&quot;#实现代码&quot; class=&quot;headerlink&quot; title=&quot;实现代码&quot;&gt;&lt;/a&gt;实现代码&lt;/h3&gt;&lt;p&gt;&lt;br&gt;&lt;/p&gt;
&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;&amp;lt;html&amp;gt;
&amp;lt;head&amp;gt;
 &amp;lt;
      
    
    </summary>
    
      <category term="代码片段" scheme="http://www.jumpbyte.cn/categories/code-block-list/"/>
    
    
      <category term="js" scheme="http://www.jumpbyte.cn/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之Bridge桥接模式（结构型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/bridge/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/bridge/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h3><p>首先我们来看下下面这个问题</p><blockquote><p>假如我们需要开发一个同时支持PC和手机的坦克游戏，游戏在PC和手机上功能都一样，都有同样的类型，面临同样的功能需求变化，比如坦克可能有多种不同的型号：T50，T75，T90..对于其中的坦克设计，我们可能很容易设计出来一个Tank的抽象类，然后各种不同型号的Tank继承自该类，但是PC和手机上的图形绘制、声效、操作等实现完全不同…因此对于各种型号的坦克，都 要提供各种不同平台上的坦克实现；而这样的设计带来了很多问题：有很多重复代码，类的结构过于复杂，难以维护，最致命的是引入任何新的平台，比如TV上的Tank游戏，都会让整个类层次级结构复杂化</p></blockquote><a id="more"></a><h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>思考上述问题的症结，事实上由于Tank类型的固有逻辑，使得Tank类型具有了两个变化的维度——一个变化的维度为“平台的变化”，一个变化的维度为“型号的变化”；如何应对这种“多维度的变化”？如何利用面向对象技术使得Tank类型可以轻松地沿着“平台”和“型号”两个方向变化，而不引入额外的复杂度呢？</p><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使用桥接模式我们主要是想将抽象部分和实现部分分离（将一个事物中多个维度的变化分离），使它们可以独立的变化 即将不同纬度的变化抽象出来，并子类化它们，用对象组合的方式实现应对其变化</p><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-3/12927396.jpg" alt="桥接模式UML图"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>按照UML图对桥接模式的描述，我们先看下在未使用桥接模式的情况下，我们这个代码是怎样的</p><h4 id="未使用桥接模式前的实现代码"><a href="#未使用桥接模式前的实现代码" class="headerlink" title="未使用桥接模式前的实现代码"></a>未使用桥接模式前的实现代码</h4><p>定义抽象坦克类和不同型号的坦克子类</p><pre><code class="C#">public abstract  class Tank{    public abstract void Run();    public abstract void Shot();    public abstract void Stop();}public class T50 : Tank{    public override void Run()    {        //....    }    public override void Shot()    {        //....    }    public override void Stop()    {        //....    }}public class T75 : Tank{    public override void Run()    {        //....    }    public override void Shot()    {        //....    }    public override void Stop()    {        //....    }}public class T90 : Tank{    public override void Run()    {        //....    }    public override void Shot()    {        //....    }    public override void Stop()    {        //....    }}</code></pre><p>假设我们的坦克游戏有针对PC,Mobile,TV这三种不同平台版本，不同平台每种型号的坦克具体实现是不一样的，为此我们需要继续扩展子类定义每个平台不同型号坦克子类及实现</p><p><strong>PC平台对不同型号坦克子类实现</strong></p><pre><code class="C#">public class PCT50 : T50{    public override void Run()    {        //TODO:pc平台具体实现    }    public override void Shot()    {      //TODO:pc平台具体实现    }    public override void Stop()    {        //TODO:pc平台具体实现    }}public class PCT75: T75{    public override void Run()    {      //TODO:pc平台具体实现    }    public override void Shot()    {      //TODO:pc平台具体实现    }    public override void Stop()    {        //TODO:pc平台具体实现    }}public class PCT90 : T90{    public override void Run()    {        //TODO:pc平台具体实现    }    public override void Shot()    {       //TODO:pc平台具体实现    }    public override void Stop()    {        //TODO:pc平台具体实现    }}</code></pre><p><strong>Mobile平台对不同型号坦克子类实现</strong></p><pre><code class="C#">public class MobileT50 : T50{    public override void Run()    {        //TODO:Mobile平台具体实现    }    public override void Shot()    {        //TODO:Mobile平台具体实现    }    public override void Stop()    {        //TODO:Mobile平台具体实现    }}public class MobileT75 : T75{    public override void Run()    {        //TODO:Mobile平台具体实现    }    public override void Shot()    {        //TODO:Mobile平台具体实现    }    public override void Stop()    {        //TODO:Mobile平台具体实现    }}public class MobileT90 : T90{    public override void Run()    {        //TODO:Mobile平台具体实现    }    public override void Shot()    {        //TODO:Mobile平台具体实现    }    public override void Stop()    {        //TODO:Mobile平台具体实现    }}</code></pre><p><strong>TV平台对不同型号坦克子类实现</strong></p><pre><code class="C#">public class TVT50 : T50{    public override void Run()    {        //TODO:TV平台具体实现    }    public override void Shot()    {      //TODO:TV平台具体实现    }    public override void Stop()    {      //TODO:TV平台具体实现    }}public class TVT75 : T75{    public override void Run()    {      //TODO:TV平台具体实现    }    public override void Shot()    {      //TODO:TV平台具体实现    }    public override void Stop()    {      //TODO:TV平台具体实现    }}public class TVT90 : T90{    public override void Run()    {      //TODO:TV平台具体实现    }    public override void Shot()    {      //TODO:TV平台具体实现    }    public override void Stop()    {      //TODO:TV平台具体实现    }}</code></pre><p>通过上述代码，我们可以看出，如果将来我们新增任意坦克或平台都要靠增加子类来解决变化，这种情况就会导致子类的繁多，不能真正的应对平台和坦克型号两个纬度增加的变化，这时桥接模式就很好的派上用场</p><h4 id="桥接模式登场"><a href="#桥接模式登场" class="headerlink" title="桥接模式登场"></a>桥接模式登场</h4><p>首先我们针对平台和坦克型号这两个纬度进行抽象</p><pre><code class="C#">namespace Bridge{  /// &lt;summary&gt;  /// 将不同平台坦克实现抽象出来（应对平台变化）  /// &lt;/summary&gt;  public abstract class TankPlatformImplementation  {      public abstract void MoveTo();      public abstract void Draw();      public abstract void Stop();  }  /// &lt;summary&gt;  /// 坦克抽象类(应对坦克型号的变化)  /// &lt;/summary&gt;  public abstract class Tank  {      TankPlatformImplementation tanklmp;//对象组合      public Tank( TankPlatformImplementation tanklmp)      {          this.tanklmp = tanklmp;      }      public abstract void Run();      public abstract void Shot();      public abstract void Stop();  }}</code></pre><p>不同平台下的坦克实现</p><pre><code class="C#">/// &lt;summary&gt;/// PC平台的Tank/// &lt;/summary&gt;public class PCTankImplementation:TankPlatformImplementation{     public override void  MoveTo()     {        //PC上的实现代码     }     public override void  Draw()     {       //PC上的实现代码     }     public override void  Stop()     {        //PC上的实现代码     } }/// &lt;summary&gt;/// Mobile平台的Tank/// &lt;/summary&gt;public class MobileTankImplementation:TankPlatformImplementation{     public override void  MoveTo()     {       // Mobile上的实现代码     }     public override void  Draw()     {       // Mobile上的实现代码     }     public override void  Stop()     {        // Mobile上的实现代码     }}</code></pre><p>不同型号坦克的子类实现</p><pre><code class="C#">public class T50 : Tank{  public T50(TankPlatformImplementation tanklmp)      : base(tanklmp)  {  }  public override void Run()  {      //....      //using tanklmp do something...      //...  }  public override void Shot()  {      //....      //using tanklmp do something...      //...  }  public override void Stop()  {      //....      //using tanklmp do something...      //...  }}public class T75 : Tank{  public T75(TankPlatformImplementation tanklmp)      : base(tanklmp)  {  }  public override void Run()  {      //....      //using tanklmp do something...      //...  }  public override void Shot()  {      //....      //using tanklmp do something...      //...  }  public override void Stop()  {      //....      //using tanklmp do something...      //...  }}</code></pre><p>以上代码实现完了之后，我们就可以很轻松的针对不同平台进行开发</p><pre><code class="C#">public class App{    public static void Main()    {       //手机平台游戏        TankPlatformImplementation mobileTank=new MobileTankImplementation();        Tank tank=new T50(mobileTank);        //tank.Shot();    }}</code></pre><h3 id="可适用性"><a href="#可适用性" class="headerlink" title="可适用性"></a>可适用性</h3><ol><li>你不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这时Bridge模式使你可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li><li>对一个抽象的实现部分的修改应对客户不产生影响，即客户的代码不必重新编译。</li><li>（C++）你想对客户完全隐藏抽象的实现部分。在C++中，类的表示在类接口中是可见的。</li><li>有许多类要生成。这样一种类层次结构说明你必须将一个对象分解成两个部分。Rumbaugh称这种类层次结构为“嵌套的普化”(nested generalizations)。</li><li>你想在多个对象间共享实现（可能使用引用计数），但同时要求客户并不知道这一点。一个简单的例子便是Coplien 的String类[Cop92]，在这个类中多个对象可以共享同一个字符串表示（StringRep ）。</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/archive/2012/02/24/3178773.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;问题分析&quot;&gt;&lt;a href=&quot;#问题分析&quot; class=&quot;headerlink&quot; title=&quot;问题分析&quot;&gt;&lt;/a&gt;问题分析&lt;/h3&gt;&lt;p&gt;首先我们来看下下面这个问题&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;假如我们需要开发一个同时支持PC和手机的坦克游戏，游戏在PC和手机上功能都一样，都有同样的类型，面临同样的功能需求变化，比如坦克可能有多种不同的型号：T50，T75，T90..对于其中的坦克设计，我们可能很容易设计出来一个Tank的抽象类，然后各种不同型号的Tank继承自该类，但是PC和手机上的图形绘制、声效、操作等实现完全不同…因此对于各种型号的坦克，都 要提供各种不同平台上的坦克实现；而这样的设计带来了很多问题：有很多重复代码，类的结构过于复杂，难以维护，最致命的是引入任何新的平台，比如TV上的Tank游戏，都会让整个类层次级结构复杂化&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="Bridge" scheme="http://www.jumpbyte.cn/tags/Bridge/"/>
    
      <category term="桥接模式" scheme="http://www.jumpbyte.cn/tags/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之TemplateMethod模板方法（行为型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/TemplateMethod/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/TemplateMethod/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现；如何在确定稳定操作结构的前提下，来灵活应对各种子步骤的变化或者晚期实现需求？</p><a id="more"></a><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。TemplateMethod是的子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。</p><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ol><li><p>一次性实现一个算法的不变的部分，并将可变的行为留给子类来实现。</p></li><li><p>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。这是Opdyke和Johnson所描述过的“重分解以一般化”的一个很好的例子[ O J 9 3 ]。首先识别现有代码中的不同之处，并且将不同之处分离为新的操作。最后，用一个调用这些新的操作的模板方法来替换这些不同的代码。</p></li><li><p>控制子类扩展。模板方法只在特定点调用“hook”,我们俗称设定一个钩子，后面去操作实现，这样就只允许在这些点进行扩展。</p></li></ol><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/TemplateMethod.jpg" alt="TemplateMethod UML图解"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="示例场景"><a href="#示例场景" class="headerlink" title="示例场景"></a>示例场景</h4><p>假设要开发一款汽车测试程序，而对于测试什么类型和什么牌子的汽车，都是是未知的。应用模板方法来设计，我们就可以先把汽车测试程序测试涉及的方法列举出来，对于某些测试方法具体实现留给后来汽车厂商去实现</p><h4 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h4><p><strong>汽车测试软件框架部分</strong></p><pre><code class="C#">//汽车测试软件框架的开发组——先开发namespace TemplateMethod{    public abstract class Vehicle    {        protected abstract void Startup();        protected abstract void Run();        protected abstract void Turn();        protected abstract void Stop();        public void Test()        {            Startup();//晚绑定，留给应用程序开发人员实现，扩展点            //测试数据记录...            Run();//晚绑定，留给应用程序开发人员实现，扩展点            //测试数据记录...            Turn();//晚绑定，留给应用程序开发人员实现，扩展点            //测试数据记录...            Stop();//晚绑定，留给应用程序开发人员实现，扩展点            //测试数据记录...        }    }    public class VehicleTestFramework    {        public static void DoTest(Vehicle vehicle)        {            //...            vehicle.Test();            //...        }    }}</code></pre><p><strong>具体汽车厂商后来实现部分</strong></p><pre><code class="C#">//具体汽车厂商汽车测试程序程序开发组——晚开发namespace TemplateMethod{    public class DaZhongCar:Vehicle    {        protected override void Startup()        {            //...        }        protected override void Run()        {            //...        }        protected override void Turn()        {            //...        }        protected override void Stop()        {            //...        }    }}</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/p/3353863.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在软件构建过程中，对于某一项任务，他常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现；如何在确定稳定操作结构的前提下，来灵活应对各种子步骤的变化或者晚期实现需求？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="模板方法" scheme="http://www.jumpbyte.cn/tags/%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95/"/>
    
      <category term="TemplateMethod" scheme="http://www.jumpbyte.cn/tags/TemplateMethod/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之Singleton单例模式（创建型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/Singleton/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/Singleton/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，经常有这样的一些特殊的类，必须保证它们在系统中 只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率</p><a id="more"></a><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>保证一个类仅有一个实例，并提供一个该实例的全局访问点</p><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-6/59535259.jpg" alt="Singleton UML图解"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>利用.Net实现单例模式，可以有几种不同的编码实现</p><p><strong>第一种实现，非线程安全</strong></p><pre><code>namespace Singleton{  //只适用单线程下的单例模式,在多线程下无法保证其唯一实例  public class Singleton  {      private static Singleton instance;      private Singleton() { }      public static Singleton Instance      {          get          {              if (instance == null)              {                  instance = new Singleton();              }              return instance;          }      }  }}</code></pre><p><strong>第二种：多线程单例模式的设计</strong></p><pre><code>/// &lt;summary&gt;/// 多线程单例模式的设计/// &lt;/summary&gt;public class Singleton{    //volatile 会保证编译器不对代码指令的执行调整顺序，而保证其严格意义上的的按顺序执行    private static volatile Singleton instance=null;    private static object lockHepler = new object();//起辅助作用    private Singleton() { }    public static Singleton Instance    {        get        {            if (instance==null)            {                lock (lockHepler)                {                    if (instance == null)                    {                        instance = new Singleton();                    }                }            }            return instance;        }    }}</code></pre><p><strong>第三种：多线程单例模式的设计</strong></p><pre><code>/// &lt;summary&gt;/// 多线程单例模式的设计/// &lt;/summary&gt;public class Singleton{    public static readonly Singleton Instance = new Singleton();//内联初始化    private Singleton() { }}</code></pre><p><strong>第三种实现的变体</strong></p><pre><code>/// &lt;summary&gt;/// 等同于第三种的实现,但这两者的弊端：就是不支持参数化传递的构造器/// &lt;/summary&gt;//public class Singleton{    public static readonly Singleton Instance;    //.NET机制会保证只有一个线程执行此行代码，以加锁的方式防止又一个线程执行    //在第一次访问任意静态字段之前，都会执行静态构造器，以保证静态字段都已初始化    static Singleton() { Instance = new Singleton(); }    private Singleton() { }}</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/archive/2012/02/24/3178779.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在软件系统中，经常有这样的一些特殊的类，必须保证它们在系统中 只存在一个实例，才能确保它们的逻辑正确性、以及良好的效率&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="Singleton" scheme="http://www.jumpbyte.cn/tags/Singleton/"/>
    
      <category term="单例模式" scheme="http://www.jumpbyte.cn/tags/%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之Prototype原型模式（创建型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/Prototype/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/Prototype/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.843Z</updated>
    
    <content type="html"><![CDATA[<h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象</p><h3 id="可适用性"><a href="#可适用性" class="headerlink" title="可适用性"></a>可适用性</h3><ol><li>当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。</li></ol><a id="more"></a><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-6/67444558.jpg" alt="原型模式UML图解"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>举一个例子，假设魂斗罗游戏，其中有各种各样的角色比如从抽象概念上有NormalActor、FlyActor、WaterActor,其中每一种角色又对应A、B、C三种具体人物等等;在游戏开始需要创建若干种人物出场进行决斗</p><p>以下就是用原型模式实现此示例的代码：</p><pre><code class="c#">using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace Prototype{    /***     * 魂斗罗游戏     * ***/    public class GameSystem    {        NormalActor na; FlyActor fa; WaterActor wa;        public void Run(NormalActor na,FlyActor fa,WaterActor wa)        {            //以下就是使用原型实例创建对象的种类；Clone()方法也实现了以后的多态特征            NormalActor na1 = na.Clone();            NormalActor na2 = na.Clone();            FlyActor fa1 = fa.Clone();            FlyActor fa2 = fa.Clone();            WaterActor wa1 = wa.Clone();            WaterActor wa2 = wa.Clone();        }    }    //角色抽象类定义    public abstract class NormalActor    {        public abstract NormalActor Clone();    }    public abstract class FlyActor    {        public abstract FlyActor Clone();    }    public abstract class WaterActor    {        public abstract WaterActor Clone();    }    /***     * 注意：在C#中this.MemberwiseClone();属于浅拷贝；即当类对象执行浅拷贝时，类中引用类型     * 的成员仍然是被共享的，即拷贝的是其引用成员的地址；要实现其深度拷贝有两种方法：     * ①即new一个该类的实例，将当前对象的成员的值一一赋给新的对象返回此新的对象     * ②使用序列化和反序列，即将当前对象序列化到内存流中，然后再将其从内存流中反序列化得到的     * 一定是深度拷贝的新对象     * ***/    //角色类的具体实现    public class NormalActorA : NormalActor    {        public override NormalActor Clone()        {            return (NormalActor)this.MemberwiseClone();        }    }    public class FlyActorA : FlyActor    {        public override FlyActor Clone()        {            return (FlyActor)this.MemberwiseClone();        }    }    public class WaterActorrA : WaterActor    {        public override WaterActor Clone()        {            return (WaterActor)this.MemberwiseClone();        }    }}</code></pre><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/archive/2012/02/24/3178775.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;意图&quot;&gt;&lt;a href=&quot;#意图&quot; class=&quot;headerlink&quot; title=&quot;意图&quot;&gt;&lt;/a&gt;意图&lt;/h3&gt;&lt;p&gt;使用原型实例指定创建对象的种类，然后通过拷贝这些原型来创建新的对象&lt;/p&gt;
&lt;h3 id=&quot;可适用性&quot;&gt;&lt;a href=&quot;#可适用性&quot; class=&quot;headerlink&quot; title=&quot;可适用性&quot;&gt;&lt;/a&gt;可适用性&lt;/h3&gt;&lt;ol&gt;
&lt;li&gt;当要实例化的类是在运行时刻指定时，例如，通过动态装载；或者为了避免创建一个与产品类层次平行的工厂类层次时&lt;/li&gt;
&lt;li&gt;当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们可能比每次用合适的状态手工实例化该类更方便一些。&lt;/li&gt;
&lt;/ol&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="Prototype" scheme="http://www.jumpbyte.cn/tags/Prototype/"/>
    
      <category term="原型模式" scheme="http://www.jumpbyte.cn/tags/%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之AbstractFactory抽象工厂模式（创建型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/AbstractFactory/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/AbstractFactory/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，经常面临着“系列相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象 的创建工作；如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？</p><a id="more"></a><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>提供一个接口，让该接口负责创建一系列“相关或者相互依赖的对象”，无需指定它们具体的类。</p><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><ol><li>一个系统要独立于它的产品的创建、组合和表示时。</li><li>一个系统要由多个产品系列中的一个来配置时。</li><li>当你要强调一系列相关的产品对象的设计以便进行联合使用时。</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时。</li></ol><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-6/51035923.jpg" alt="AbstractFactory UML图解"></p><p><em>注：图片来源与网络，在此表示感谢</em></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设在一个游戏场景中，其中有一些场景设施，房屋，道路，隧道,丛林等等，每种设施都有几种不同的风格（古老风格，现代风格等），游戏可能会在不同的风格中进行切换，此时我们如何去应对风格切换带来游戏场景设施对象的变化？抽象工厂模式就可以运用于此。</p><p>首先，对我们游戏场景的一系列设施进行对象抽象化</p><pre><code class="C#">/// &lt;summary&gt;/// 路（抽象类）/// &lt;/summary&gt;public abstract class Road{}/// &lt;summary&gt;/// 房屋（抽象类）/// &lt;/summary&gt;public abstract class Building{}/// &lt;summary&gt;/// 隧道（抽象类）/// &lt;/summary&gt;public abstract class Tunnel{}/// &lt;summary&gt;/// 丛林（抽象类）/// &lt;/summary&gt;public abstract class Jungle{}</code></pre><p>其具体风格的场景设施子类如下</p><p><strong>现代风格基础场景设施子类</strong></p><pre><code class="C#">// &lt;summary&gt;/// 现代风格的路/// &lt;/summary&gt;public  class ModernRoad:Road{}/// &lt;summary&gt;/// 现代风格的房屋/// &lt;/summary&gt;public class ModernBuilding:Building{}/// &lt;summary&gt;/// 现代风格的隧道/// &lt;/summary&gt;public class ModernTunnel:Tunnel{}/// &lt;summary&gt;/// 现代风格的丛林/// &lt;/summary&gt;public class ModernJungle:Jungle{}</code></pre><p><strong>古老风格场景设施子类</strong></p><pre><code class="C#">/// &lt;summary&gt;/// 古老风格的路/// &lt;/summary&gt;public class AncientRoad : Road{}/// &lt;summary&gt;/// 古老风格的房屋/// &lt;/summary&gt;public class AncientBuilding : Building{}/// &lt;summary&gt;/// 古老风格的隧道/// &lt;/summary&gt;public class AncientTunnel : Tunnel{}/// &lt;summary&gt;/// 古老风格的丛林/// &lt;/summary&gt;public class AncientJungle : Jungle{}</code></pre><p>接下来，我们要使用工厂创建这些子类，但对于不同风格的子类，我们要用不同风格的工厂类去创建，所以我们需要定一个抽象工厂类，然后派生出不同风格的具体工厂类</p><pre><code class="C#">/// &lt;summary&gt;/// 场景设施抽象创建工厂类/// &lt;/summary&gt;public abstract class FacilitiesFactory{    public abstract Road CreateRoad();    public abstract Building CreateBuilding();    public abstract Tunnel CreateTunnel();    public abstract Jungle CreateJungle();}</code></pre><p>现代风格和古老风格工厂类，继承自场景设施抽象创建工厂类</p><pre><code class="C#">/// &lt;summary&gt;/// 现代风格的对象创建工厂类/// &lt;/summary&gt;public class ModernFacilitiesFactory : FacilitiesFactory{    public override Road CreateRoad()    {        return new ModernRoad();    }    public override Building CreateBuilding()    {        return new ModernBuilding();    }    public override Tunnel CreateTunnel()    {        return new ModernTunnel();    }    public override Jungle CreateJungle()    {        return new ModernJungle();    }}/// &lt;summary&gt;/// 古代风格的对象创建工厂类/// &lt;/summary&gt;public class AncientFacilitiesFactory : FacilitiesFactory{    public override Road CreateRoad()    {        return new AncientRoad();    }    public override Building CreateBuilding()    {        return new AncientBuilding();    }    public override Tunnel CreateTunnel()    {        return new AncientTunnel();    }    public override Jungle CreateJungle()    {        return new AncientJungle();    }}</code></pre><p>然后，客户程序中我们就可以使用不同的工厂去创建不同风格的场景设施</p><pre><code class="C#">/// &lt;summary&gt;/// 假设此类为客户程序/// &lt;/summary&gt;public class GameManager{    /***     * 当需要增加另一种风格的场景时，只需要继承对应的抽象类实现此风格下的实例对象类和具体工厂类即可     * 而客户程序无需改动或改动甚少，这既是这种设计模式的优势     * ***/    FacilitiesFactory _facilitiesfactory;    Road road;    Building building;    Tunnel tunnel;    Jungle jungle;    public GameManager(FacilitiesFactory facilitiesfactory )    {        this._facilitiesfactory = facilitiesfactory;    }    /// &lt;summary&gt;    /// 创建游戏场景    /// &lt;/summary&gt;    public void BuildGameFacilities()    {        road = _facilitiesfactory.CreateRoad();        building = _facilitiesfactory.CreateBuilding();        tunnel = _facilitiesfactory.CreateTunnel();        jungle = _facilitiesfactory.CreateJungle();    }    /// &lt;summary&gt;    /// 开始游戏    /// &lt;/summary&gt;    public void Play()    {    }}public class App{    public static void Main()    {        FacilitiesFactory ff = new ModernFacilitiesFactory();        GameManager game = new GameManager(ff);        game.BuildGameFacilities();        game.Play();    }}</code></pre><p>如此，在客户端代码中，想使用什么风格的场景设施，只要在new的时候指定具体风格的工厂类，即可实现不同场景设施风格的切换</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/p/3353829.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在软件系统中，经常面临着“系列相互依赖的对象”的创建工作：同时，由于需求的变化，往往存在更多系列对象 的创建工作；如何应对这种变化？如何绕过常规的对象创建方法（new），提供一种“封装机制”来避免客户程序和这种“多系列具体对象创建工作”的紧耦合？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="AbstractFactory" scheme="http://www.jumpbyte.cn/tags/AbstractFactory/"/>
    
      <category term="抽象工厂模式" scheme="http://www.jumpbyte.cn/tags/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之Builder生成器模式（创建型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/Builder/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/Builder/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，有时候面临着“一个复杂对象”的创建工作， 其通常由各个部分的子对象用一定的算法构成；由于需求的变化， 这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起 的算法却相对稳定；如何应对这种变化？如何提供一种“封装机制”来隔离复杂对象的各个部分的变化，从而保持系统中的“稳定构建算法不随需求的 改变而改变</p><a id="more"></a><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个复杂对象的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。——《设计模式》GOF</p><h3 id="适用性"><a href="#适用性" class="headerlink" title="适用性"></a>适用性</h3><p>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时。当构造过程必须允许被构造的对象有不同的表示时。</p><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-6/70604525.jpg" alt="Builder模式UML图解"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设我们有一个游戏场景，在进入游戏场景时，我们需要构建一个游戏的房屋，房屋由两扇门，四面墙，四个窗户，两个地板，一个天花板构成，我们目的在于如何在游戏进入时去构造这些对象从而构建一个完整的房屋</p><p>首先将房屋进行抽象，定一个广泛意义的房屋和和构成房屋的基础设施(门，墙，窗户，地板，天花板)</p><p><code>house.cs文件代码</code></p><pre><code class="C#">public abstract class House{}//房屋public abstract class Door{}//窗户public abstract class Windows{}//地板public abstract class Floor{}//墙public abstract class Wall{}//天花板public abstract class HouseCeiling{}</code></pre><p><code>RomainHouse.cs文件代码</code></p><pre><code class="C#">//罗马屋public class RomainHouse:House{}public class RomainDoor : Door{}public class RomainWindows : Windows{}public class RomainWall : Wall{}public class RomainFloor : Floor{}public class RomainHouseCeiling: HouseCeiling{}</code></pre><p><code>Builder.cs文件代码</code></p><pre><code class="C#">/// &lt;summary&gt;/// 游戏中的房屋生成器（抽象层次）/// &lt;/summary&gt;public abstract class Builder{    public abstract void BuildDoor();    public abstract void BuildWall();    public abstract void BuildWindows();    public abstract void BuildFloor();    public abstract void BuildHouseCeiling();    public abstract House GetHouse();}/// &lt;summary&gt;/// 具体罗马房屋生成器/// &lt;/summary&gt;public class RomainHouseBuilder : Builder{    private House house=new RomainHouse();    public override void BuildDoor()    {       //TODO:door...    }    public override void BuildWall()    {        //TODO:wall...    }    public override void BuildWindows()    {        //TODO:windows...    }    public override void BuildFloor()    {        //TODO:floor...    }    public override void BuildHouseCeiling()    {        //TODO:build a HouseCeiling...    }    public override House GetHouse()    {        return  house;    }}</code></pre><p>定一个GameManager，用构造一个房屋</p><pre><code class="C#">/// &lt;summary&gt;///GameManager,包含房屋的构建及过程实现，这里的构建过程算法是不经常变化的，是稳定的/// &lt;/summary&gt;public class GameManager{    //构建过程(即算法是不经常变化的)是稳定的...    public static House CreateHouse(Builder builder)    {        //两扇门        builder.BuildDoor();        builder.BuildDoor();        //四个窗户        builder.BuildWindows();        builder.BuildWindows();        builder.BuildWindows();        builder.BuildWindows();        //四面墙        builder.BuildWall();        builder.BuildWall();        builder.BuildWall();        builder.BuildWall();        //两块地板        builder.BuildFloor();        builder.BuildFloor();        //一个天花板        builder.BuildHouseCeiling();        return builder.GetHouse();    }}</code></pre><p>最后做的事情就是在具体客户端去使用和调用</p><pre><code class="C#">/// &lt;summary&gt;///客户端，直接使用GameManager来获取一个房屋/// &lt;/summary&gt;public class App{    public  static void Main()    {       //从配置文件中动态加载具体房屋生成器dll，保证了客户代码的稳定性；即当你的应用程序       //版本升级时，你只需要将改变的dll给用户，另者再修改一下配置文件即可扩展此程序        string assemblyName=ConfigurationManager.AppSettings[&quot;BuilderAssembly&quot;];        string builderName=ConfigurationManager.AppSettings[&quot;BuilderName&quot;];        Assembly builderAssembly = Assembly.Load(assemblyName);        Type builderType = builderAssembly.GetType(builderName);        Builder builder =(Builder)Activator.CreateInstance(builderType);        House house = GameManager.CreateHouse(builder);        //House house=GameManager.CreateHouse(new RomainHouseBuilder());    }}</code></pre><p>在上述客户端调用的代码中，我们使用了反射来解决耦合，即便当房屋的风格变化时,只需要继承Builder实现其对应的具体风格房屋的生成器即可而客户代码可以通过配置文件的形式，通过.NET的反射机制调用改变后的具体生成器</p><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/archive/2012/02/24/3178776.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在软件系统中，有时候面临着“一个复杂对象”的创建工作， 其通常由各个部分的子对象用一定的算法构成；由于需求的变化， 这个复杂对象的各个部分经常面临着剧烈的变化，但是将它们组合在一起 的算法却相对稳定；如何应对这种变化？如何提供一种“封装机制”来隔离复杂对象的各个部分的变化，从而保持系统中的“稳定构建算法不随需求的 改变而改变&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="Builder" scheme="http://www.jumpbyte.cn/tags/Builder/"/>
    
      <category term="生成器模式" scheme="http://www.jumpbyte.cn/tags/%E7%94%9F%E6%88%90%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>面向对象设计模式之Adapter适配器模式（结构型）</title>
    <link href="http://www.jumpbyte.cn/2013/10/06/Adapter/"/>
    <id>http://www.jumpbyte.cn/2013/10/06/Adapter/</id>
    <published>2013-10-06T16:36:00.000Z</published>
    <updated>2017-12-03T09:27:22.839Z</updated>
    
    <content type="html"><![CDATA[<h3 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h3><p>在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口使这些现存对象所不满足的。如何应对这种“迁移的变化”？如何即能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？</p><a id="more"></a><h3 id="意图"><a href="#意图" class="headerlink" title="意图"></a>意图</h3><p>将一个类的接口转换成客户希望的另一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作</p><h3 id="可适用性"><a href="#可适用性" class="headerlink" title="可适用性"></a>可适用性</h3><ol><li>你想使用一个已经存在的类，而它的接口不符合你的需求。</li><li>你想创建一个可以复用的类，该类可以与其他不相关的类或不可预见的类（即那些接口可能不一定兼容的类）协同工作。</li><li>（仅适用于对象Adapter）你想使用一些已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口</li></ol><h3 id="UML图解"><a href="#UML图解" class="headerlink" title="UML图解"></a>UML图解</h3><p><img src="http://oaefo3hoy.bkt.clouddn.com/16-8-6/36475031.jpg" alt="适配器模式UML图解"></p><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>根据上面的UML图，我们可以用代码来实际演示如何具体应用此模式</p><pre><code class="C#">using System;using System.Collections.Generic;using System.Linq;using System.Text;namespace Adapter{    /// &lt;summary&gt;    /// 客户所需要期待的接口    /// &lt;/summary&gt;    public abstract class  Target    {        public abstract  void Request();    }    /// &lt;summary&gt;    /// 需要适配的类    /// &lt;/summary&gt;    public class Adaptee    {        public void SpecificRequest()        {            Console.WriteLine(&quot;特殊请求！&quot;);        }    }    /// &lt;summary&gt;    /// 通过内部接口包装一个Adaptee对象，将源接口转换成目标接口    /// &lt;/summary&gt;    public class Adapter:Target    {        Adaptee _adaptee = new Adaptee();//适配对象，也可通过参数传递        public override void Request()        {            //这样就可以把表面上调用Request()方法变成实际调用SpecificRequest()            _adaptee.SpecificRequest();          }    }    public class Client    {       public  static void Main()        {            Target target = new Adapter();            target.Request();//对客户端来说，调用的就是Target的Request();        }    }}</code></pre><h3 id="适配器模式在-NET中的应用"><a href="#适配器模式在-NET中的应用" class="headerlink" title="适配器模式在.NET中的应用"></a>适配器模式在.NET中的应用</h3><ol><li>在.NET中复用COM对象：COM对象不符合.NET对象的接口；它使用tlbimp.exe来创建一个Runtime Callable Wrapper(RCW)以使其符合.NET对象的接口</li><li>NET数据访问类（Adapter变体）：各种数据库并没有提供DataSet接口；使用DbDataAdapter可以将任何各种数据库访问/存取适配到一个DataSet对象上。</li><li>集合类中对现有对象的排序（Adapter变体）：现有对象未实现IComparable接口；实现一个排序适配器（继承IComparer接口），然后在其Compare方法中对两个对象进行比较</li></ol><h3 id="几个要点"><a href="#几个要点" class="headerlink" title="几个要点"></a>几个要点</h3><ol><li>Adapter模式主要应用于“希望复用一些现存的类，但是接口又于复用环境要求不一致的情况”，在遗留代码复用、类库迁移等方面非常有用</li><li>GoF23定义了两种Adapter模式的实现结构：对象适配器和类适配器。但类适配器采用“多继承”的实现<br>方式，带来了不良的高耦合，所以一般不推荐使用。对象适配器采用“对象组合”的方式，更符合松耦合精神。</li><li>Adapter模式可以实现的非常灵活，不必拘泥于GoF23中定义的两种结构。例如，完全可以将Adapter模式中的“现存对象”作为新的接口方法参数，来达到适配的目的</li><li>Adapter模式本身要求我们尽可能的使用“面向接口的编程”风格，这样才能在后期很方便地适配</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><p>博客搬家至此，原文可以访问<a href="http://www.cnblogs.com/yja9010/archive/2012/02/24/3178774.html" target="_blank" rel="external">这里</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h3&gt;&lt;p&gt;在软件系统中，由于应用环境的变化，常常需要将“一些现存的对象”放在新的环境中应用，但是新环境要求的接口使这些现存对象所不满足的。如何应对这种“迁移的变化”？如何即能利用现有对象的良好实现，同时又能满足新的应用环境所要求的接口？&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://www.jumpbyte.cn/categories/gof23/"/>
    
    
      <category term="Adapter" scheme="http://www.jumpbyte.cn/tags/Adapter/"/>
    
      <category term="适配器模式" scheme="http://www.jumpbyte.cn/tags/%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
